import math
from copy import deepcopy
import chess
import chess.engine
from typing import Any, Dict, List, Optional, Set, Tuple

from engine_utils.prophylaxis import detect_prophylaxis_plan_drop, PlanDropResult
from rule_tagger2.legacy.prophylaxis import (
    ProphylaxisConfig,
    classify_prophylaxis_quality,
    clamp_preventive_score,
    estimate_opponent_threat,
    is_prophylaxis_candidate,
    prophylaxis_pattern_reason,
)

from .config import (
    CONTROL,
    CONTROL_DEFAULTS,
    CENTER_FILES,
    CENTER_TOLERANCE,
    CONTROL_BLUNDER_THREAT_THRESH,
    CONTROL_COOLDOWN_PLIES,
    CONTROL_EVAL_DROP,
    CONTROL_KING_SAFETY_THRESH,
    CONTROL_OPP_MOBILITY_DROP,
    CONTROL_PHASE_WEIGHTS,
    CONTROL_SIMPLIFY_MIN_EXCHANGE,
    CONTROL_TACTICAL_WEIGHT_CEILING,
    CONTROL_TENSION_DELTA,
    CONTROL_TENSION_DELTA_ENDGAME,
    CONTROL_VOLATILITY_DROP_CP,
    DELTA_EVAL_POSITIONAL,
    INITIATIVE_BOOST,
    KING_SAFETY_GAIN,
    KING_SAFETY_TOLERANCE,
    MOBILITY_RISK_TRADEOFF,
    MOBILITY_TOLERANCE,
    RISK_SMALL_LOSS,
    STRUCTURE_DOMINANCE_LIMIT,
    STRUCTURE_THRESHOLD,
    STYLE_COMPONENT_KEYS,
    TACTICAL_DELTA_TACTICS,
    TACTICAL_DOMINANCE_THRESHOLD,
    TACTICAL_GAP_FIRST_CHOICE,
    TACTICAL_MISS_LOSS,
    TACTICAL_SLOPE_THRESHOLD,
    TACTICAL_THRESHOLD,
    TENSION_EVAL_MAX,
    TENSION_EVAL_MIN,
    TENSION_SYMMETRY_TOL,
    NEUTRAL_TENSION_BAND,
)
from rule_tagger2.core.engine_io import (
    analyse_candidates,
    contact_profile,
    defended_square_count,
    eval_specific_move,
    evaluation_and_metrics,
    estimate_phase_ratio,
    material_balance,
    metrics_delta,
    simulate_followup_metrics,
)
from .analysis import (
    _soft_gate_weight,
    backward_delta,
    blockage_penalty,
    compute_behavior_scores,
    compute_premature_compensation,
    compute_tactical_weight,
    compute_tau,
    detect_risk_avoidance,
    file_pressure,
    infer_intent_hint,
    is_attacking_pawn_push,
    open_file_score,
)
from .models import Candidate, StyleTracker, TagResult
from .move_utils import classify_move, parse_move, is_dynamic, is_quiet
from .sacrifice import classify_sacrifice
from .core_v8 import tag_position as legacy_tag_position_v8
from .thresholds import (
    AGGRESSION_THRESHOLD,
    FILE_PRESSURE_THRESHOLD,
    LOSING_TAU_MIN,
    LOSING_TAU_SCALE,
    MOBILITY_SELF_LIMIT,
    PASSIVE_PLAN_EVAL_DROP,
    PASSIVE_PLAN_MOBILITY_OPP,
    PASSIVE_PLAN_MOBILITY_SELF,
    PLAN_DROP_DEPTH,
    PLAN_DROP_ENABLED,
    PLAN_DROP_EVAL_CAP,
    PLAN_DROP_MULTIPV,
    PLAN_DROP_OPP_MOBILITY_GATE,
    PLAN_DROP_PLAN_LOSS_MIN,
    PLAN_DROP_PSI_MIN,
    PLAN_DROP_RUNTIME_CAP_MS,
    PLAN_DROP_SAMPLE_RATE,
    PLAN_DROP_VARIANCE_CAP,
    PREMATURE_ATTACK_HARD,
    PREMATURE_ATTACK_THRESHOLD,
    RISK_AVOIDANCE_MOBILITY_DROP,
    SOFT_BLOCK_SCALE,
    SOFT_GATE_MIDPOINT,
    SOFT_GATE_WIDTH,
    STATIC_BLOCKAGE_MARGIN,
    STATIC_BLOCKAGE_THRESHOLD_BASE,
    STRUCTURE_WEAKEN_LIMIT,
    TENSION_CONTACT_DELAY,
    TENSION_CONTACT_DIRECT,
    TENSION_CONTACT_JUMP,
    TENSION_MOBILITY_DELAY,
    TENSION_MOBILITY_NEAR,
    TENSION_MOBILITY_THRESHOLD,
    TENSION_SUSTAIN_MIN,
    TENSION_SUSTAIN_VAR_CAP,
    TENSION_TREND_OPP,
    TENSION_TREND_SELF,
    THRESHOLDS,
    VOLATILITY_DROP_TOL,
    WINNING_TAU_MAX,
    WINNING_TAU_SCALE,
)
from rule_tagger2.core.context import EvalBundles, Followups, PositionContext, ThresholdsView
from rule_tagger2.core.detectors.maneuver import detect_maneuver
from rule_tagger2.core.gating import TAG_PRIORITY, TENSION_TRIGGER_PRIORITY, apply_tactical_gating
from rule_tagger2.core.tagging import assemble_tags
from rule_tagger2.core.thresholds import load_thresholds

THRESHOLDS_VIEW = ThresholdsView(load_thresholds().values)
TAG_ALIAS_MAP = {
    "misplaced_maneuver": "failed_maneuver",
}

PROPHYLAXIS_CONFIG = ProphylaxisConfig(
    preventive_trigger=THRESHOLDS["prophylaxis_preventive_trigger"],
    safety_cap=THRESHOLDS["prophylaxis_safety_bonus_cap"],
    score_threshold=THRESHOLDS["prophylaxis_preventive_trigger"],
    structure_min=THRESHOLDS.get("prophylaxis_structure_min", ProphylaxisConfig.structure_min),
    self_mobility_tol=THRESHOLDS.get("prophylaxis_self_mobility_tol", ProphylaxisConfig.self_mobility_tol),
    threat_depth=int(THRESHOLDS.get("prophylaxis_threat_depth", ProphylaxisConfig.threat_depth)),
    threat_drop=THRESHOLDS.get("prophylaxis_threat_drop", ProphylaxisConfig.threat_drop),
)
PROPHYLAXIS_STRUCTURE_MIN = PROPHYLAXIS_CONFIG.structure_min
PROPHYLAXIS_SELF_MOBILITY_TOL = PROPHYLAXIS_CONFIG.self_mobility_tol
PROPHYLAXIS_SCORE_THRESHOLD = PROPHYLAXIS_CONFIG.score_threshold
PROPHYLAXIS_THREAT_DROP = PROPHYLAXIS_CONFIG.threat_drop
PROPHYLAXIS_PREVENTIVE_TRIGGER = PROPHYLAXIS_CONFIG.preventive_trigger
PROPHYLAXIS_SAFETY_CAP = PROPHYLAXIS_CONFIG.safety_cap
PROPHYLAXIS_THREAT_DEPTH = PROPHYLAXIS_CONFIG.threat_depth

COD_SUBTYPES: Tuple[str, ...] = (
    "simplify",
    "plan_kill",
    "freeze_bind",
    "blockade_passed",
    "file_seal",
    "king_safety_shell",
    "space_clamp",
    "regroup_consolidate",
    "slowdown",
)

LEGACY_COD_BRIDGE = {
    "simplify": "simplify",
    "slowdown": "slowdown",
    "freeze": "freeze_bind",
    "king_safety": "king_safety_shell",
    "prophylaxis": "plan_kill",
}

STRICT_MODE_VOL_DELTA = 5
STRICT_MODE_MOB_DELTA = 1


def _control_flags() -> Tuple[bool, bool]:
    enabled = CONTROL.get("enabled")
    if enabled is None:
        enabled = CONTROL.get("ENABLED", True)
    strict_mode = CONTROL.get("strict_mode")
    if strict_mode is None:
        strict_mode = CONTROL.get("STRICT_MODE", False)
    return bool(enabled), bool(strict_mode)


def _strict_mode_config(base: Dict[str, Any]) -> Dict[str, Any]:
    cfg = deepcopy(base)
    vol_base = cfg.get("VOLATILITY_DROP_CP", CONTROL_VOLATILITY_DROP_CP)
    if isinstance(vol_base, (int, float)):
        cfg["VOLATILITY_DROP_CP"] = vol_base + STRICT_MODE_VOL_DELTA
    else:
        cfg["VOLATILITY_DROP_CP"] = CONTROL_VOLATILITY_DROP_CP + STRICT_MODE_VOL_DELTA
    mob_base = cfg.get("OP_MOBILITY_DROP", CONTROL_OPP_MOBILITY_DROP)
    if isinstance(mob_base, (int, float)):
        cfg["OP_MOBILITY_DROP"] = mob_base + STRICT_MODE_MOB_DELTA
    else:
        cfg["OP_MOBILITY_DROP"] = CONTROL_OPP_MOBILITY_DROP + STRICT_MODE_MOB_DELTA
    phase_adjust = cfg.get("PHASE_ADJUST")
    if isinstance(phase_adjust, dict):
        for entry in phase_adjust.values():
            if not isinstance(entry, dict):
                continue
            vol_bonus = entry.get("VOL_BONUS", 0)
            if isinstance(vol_bonus, (int, float)):
                entry["VOL_BONUS"] = vol_bonus + STRICT_MODE_VOL_DELTA
            else:
                entry["VOL_BONUS"] = STRICT_MODE_VOL_DELTA
            mob_bonus = entry.get("OP_MOB_DROP", 0)
            if isinstance(mob_bonus, (int, float)):
                entry["OP_MOB_DROP"] = mob_bonus + STRICT_MODE_MOB_DELTA
            else:
                entry["OP_MOB_DROP"] = STRICT_MODE_MOB_DELTA
    cfg["_strict_deltas"] = {
        "VOLATILITY_DROP_CP": STRICT_MODE_VOL_DELTA,
        "OP_MOBILITY_DROP": STRICT_MODE_MOB_DELTA,
    }
    return cfg


def _resolve_control_config() -> Tuple[Dict[str, Any], bool, bool]:
    enabled, strict_mode = _control_flags()
    if strict_mode:
        cfg = _strict_mode_config(CONTROL)
    else:
        cfg = CONTROL
    return cfg, enabled, strict_mode


def phase_bonus(ctx: Dict[str, Any], cfg: Dict[str, Any]) -> Dict[str, float]:
    """Return phase-dependent threshold adjustments."""
    adjust_map = cfg.get("PHASE_ADJUST", {})
    phase = ctx.get("phase") or "MID"
    defaults = {"VOL_BONUS": 0.0, "OP_MOB_DROP": 0.0}
    phase_adjust = adjust_map.get(phase, {})
    bonus = defaults.copy()
    bonus["VOL_BONUS"] = float(phase_adjust.get("VOL_BONUS", defaults["VOL_BONUS"]))
    bonus["OP_MOB_DROP"] = float(phase_adjust.get("OP_MOB_DROP", defaults["OP_MOB_DROP"]))
    return bonus


def reason(_: Dict[str, Any], message: str) -> str:
    """Lightweight helper to keep note assembly consistent."""
    return message.strip()


def _forward_square(square: int, color: chess.Color) -> Optional[int]:
    """Square immediately in front of the pawn for the given perspective."""
    step = 8 if color == chess.WHITE else -8
    target = square + step
    if 0 <= target <= 63:
        return target
    return None


def _count_passed_push_targets(
    board: chess.Board,
    color: chess.Color,
) -> Tuple[int, Dict[int, int]]:
    """
    Count immediate push targets for passed pawns and map blocking squares to pawn squares.
    """
    count = 0
    blockers: Dict[int, int] = {}
    for square in board.pieces(chess.PAWN, color):
        if not _is_passed_pawn(board, square, color):
            continue
        front = _forward_square(square, color)
        if front is None:
            continue
        if board.piece_at(front) is None:
            count += 1
        else:
            blockers[front] = square
    return count, blockers


def _is_passed_pawn(board: chess.Board, square: int, color: chess.Color) -> bool:
    """
    Compatibility wrapper for python-chess versions without Board.is_passed_pawn.
    """
    probe = getattr(board, "is_passed_pawn", None)
    if callable(probe):
        try:
            return bool(probe(square))  # python-chess >= 1.0
        except TypeError:
            return bool(probe(square, color))  # older signature with color

    enemy_color = not color
    enemy_pawns = board.pieces(chess.PAWN, enemy_color)
    file_idx = chess.square_file(square)
    rank_idx = chess.square_rank(square)
    rank_range = range(rank_idx + 1, 8) if color == chess.WHITE else range(rank_idx - 1, -1, -1)
    for df in (-1, 0, 1):
        f = file_idx + df
        if f < 0 or f > 7:
            continue
        for r in rank_range:
            target = chess.square(f, r)
            if target in enemy_pawns:
                return False
    return True


def _phase_bucket(phase_ratio: float) -> str:
    if phase_ratio <= 0.33:
        return "endgame"
    if phase_ratio <= 0.66:
        return "middlegame"
    return "opening"


_PHASE_NAME_NORMALIZED = {
    "opening": "OPEN",
    "open": "OPEN",
    "middlegame": "MID",
    "middle": "MID",
    "midgame": "MID",
    "mid": "MID",
    "endgame": "END",
    "end": "END",
}


def _normalize_phase_label(phase_name: Optional[str]) -> str:
    if not phase_name:
        return "MID"
    lowered = phase_name.lower()
    return _PHASE_NAME_NORMALIZED.get(lowered, phase_name.upper())


_DEBUG_CTX_KEYS: Tuple[str, ...] = (
    "phase",
    "phase_ratio",
    "volatility_drop_cp",
    "opp_mobility_drop",
    "tension_delta",
    "king_safety_gain",
    "preventive_score",
    "threat_delta",
    "break_candidates_delta",
    "opp_line_pressure_drop",
    "selected_kind",
    "cooldown_hit",
    "suppressed_by",
)


def _maybe_attach_control_context_snapshot(ctx: Dict[str, Any], notes: Dict[str, str]) -> None:
    if not CONTROL.get("DEBUG_CONTEXT"):
        return
    summary_parts = []
    for key in _DEBUG_CTX_KEYS:
        value = ctx.get(key)
        if isinstance(value, float):
            formatted = f"{value:+.2f}"
        else:
            formatted = str(value)
        summary_parts.append(f"{key}={formatted}")
    notes["control_ctx_debug"] = ", ".join(summary_parts)


def _count_legal_moves_for(board: chess.Board, color: chess.Color) -> int:
    probe = board.copy(stack=False)
    probe.turn = color
    return sum(1 for _ in probe.legal_moves)


def _contact_stats(board: chess.Board, color: chess.Color) -> Dict[str, float]:
    probe = board.copy(stack=False)
    probe.turn = color
    ratio, total, capture_moves, checking_moves = contact_profile(probe)
    contact_total = capture_moves + checking_moves
    return {
        "ratio": ratio,
        "total": total,
        "contact": contact_total,
        "captures": capture_moves,
        "checks": checking_moves,
    }


def _control_tension_threshold(phase_bucket: str) -> float:
    weight = CONTROL_PHASE_WEIGHTS.get(phase_bucket, 1.0)
    base = CONTROL_TENSION_DELTA * weight
    if phase_bucket == "endgame":
        base = min(base, CONTROL_TENSION_DELTA_ENDGAME)
    return base


def _current_ply_index(board: chess.Board, actor: chess.Color) -> int:
    base = max(0, (board.fullmove_number - 1) * 2)
    return base if actor == chess.WHITE else base + 1


def _active_piece_count(board: chess.Board) -> int:
    return sum(
        1
        for piece in board.piece_map().values()
        if piece.piece_type not in (chess.KING, chess.PAWN)
    )


def _active_piece_count_for(board: chess.Board, color: chess.Color) -> int:
    """Count active non-pawn pieces for a specific side."""
    total = 0
    for square in chess.SquareSet(board.occupied_co[color]):
        piece = board.piece_at(square)
        if piece and piece.piece_type not in (chess.KING, chess.PAWN):
            total += 1
    return total


def _collect_control_metrics(
    board: chess.Board,
    played_board: chess.Board,
    actor: chess.Color,
    played_move: chess.Move,
    phase_ratio: float,
    delta_eval_cp: int,
    drop_cp: int,
    change_played_vs_before: Dict[str, float],
    opp_change_played_vs_before: Dict[str, float],
    analysis_meta: Dict[str, Any],
    material_delta_self: float,
) -> Dict[str, Any]:
    phase_name = _phase_bucket(phase_ratio)
    volatility_before_cp = abs(analysis_meta.get("depth_jump_cp", 0)) + abs(analysis_meta.get("deepening_gain_cp", 0))
    volatility_after_cp = analysis_meta.get("control_volatility_after_cp")
    if volatility_after_cp is None:
        volatility_after_cp = max(abs(drop_cp), abs(delta_eval_cp))
    volatility_drop_cp = max(0.0, volatility_before_cp - volatility_after_cp)

    self_contact_before = _contact_stats(board, actor)
    opp_contact_before = _contact_stats(board, not actor)
    self_contact_after = _contact_stats(played_board, actor)
    opp_contact_after = _contact_stats(played_board, played_board.turn)

    tension_before = self_contact_before["contact"] + opp_contact_before["contact"]
    tension_after = self_contact_after["contact"] + opp_contact_after["contact"]
    tension_delta = tension_after - tension_before

    opp_mobility_before = _count_legal_moves_for(board, not actor)
    opp_mobility_after = _count_legal_moves_for(played_board, played_board.turn)
    opp_mobility_drop = opp_mobility_before - opp_mobility_after

    captured_piece = board.piece_at(played_move.to_square)
    active_before = _active_piece_count(board)
    active_after = _active_piece_count(played_board)
    own_active_before = _active_piece_count_for(board, actor)
    own_active_after = _active_piece_count_for(played_board, actor)
    opp_active_before = _active_piece_count_for(board, not actor)
    opp_active_after = _active_piece_count_for(played_board, not actor)

    own_active_drop = max(0, own_active_before - own_active_after)
    opp_active_drop = max(0, opp_active_before - opp_active_after)
    total_active_drop = max(0, active_before - active_after)

    captures_this_ply = 1 if (captured_piece or board.is_en_passant(played_move)) else 0
    square_defended_by_opp = len(played_board.attackers(not actor, played_move.to_square))
    square_defended_by_self = len(played_board.attackers(actor, played_move.to_square))

    piece_values_cp = {
        chess.PAWN: 100,
        chess.KNIGHT: 300,
        chess.BISHOP: 300,
        chess.ROOK: 500,
        chess.QUEEN: 900,
        chess.KING: 0,
    }
    captured_value_cp = piece_values_cp.get(captured_piece.piece_type, 0) if captured_piece else 0
    material_delta_self_cp = int(round(material_delta_self * 100))

    metrics = {
        "phase_bucket": phase_name,
        "volatility_before_cp": volatility_before_cp,
        "volatility_after_cp": volatility_after_cp,
        "volatility_drop_cp": volatility_drop_cp,
        "tension_before": tension_before,
        "tension_after": tension_after,
        "tension_delta": tension_delta,
        "self_contact_before": self_contact_before,
        "self_contact_after": self_contact_after,
        "opp_contact_before": opp_contact_before,
        "opp_contact_after": opp_contact_after,
        "opp_mobility_before": opp_mobility_before,
        "opp_mobility_after": opp_mobility_after,
        "opp_mobility_drop": opp_mobility_drop,
        "structure_gain": change_played_vs_before.get("structure", 0.0),
        "center_gain": change_played_vs_before.get("center_control", 0.0),
        "king_safety_gain": change_played_vs_before.get("king_safety", 0.0),
        "self_mobility_change": change_played_vs_before.get("mobility", 0.0),
        "opp_mobility_change_eval": opp_change_played_vs_before.get("mobility", 0.0),
        "opp_tactics_change_eval": opp_change_played_vs_before.get("tactics", 0.0),
        "material_delta_self": material_delta_self,
        "captured_piece_type": captured_piece.piece_type if captured_piece else None,
        "is_capture": bool(captured_piece or board.is_en_passant(played_move)),
        "active_piece_drop": total_active_drop,
        "own_active_drop": own_active_drop,
        "opp_active_drop": opp_active_drop,
        "total_active_drop": total_active_drop,
        "captures_this_ply": captures_this_ply,
        "square_defended_by_opp": square_defended_by_opp,
        "square_defended_by_self": square_defended_by_self,
        "captured_value_cp": captured_value_cp,
        "material_delta_self_cp": material_delta_self_cp,
    }
    return metrics


def _format_control_summary(kind: str, metrics: Dict[str, Any]) -> str:
    if kind == "slowdown":
        return (
            f"CoD.slowdown: eval drop {metrics['eval_drop_cp']/100:.2f}, "
            f"volatility drop {metrics['volatility_drop_cp']:.1f}cp, "
            f"tensionΔ {metrics['tension_delta']:+.0f}, "
            f"opp mobilityΔ {metrics['opp_mobility_drop']:+.0f}"
        )
    if kind == "simplify":
        captured = metrics.get("captured_piece")
        captured_label = captured if captured else "trade"
        return (
            f"CoD.simplify: {captured_label} reduced active pieces by {metrics['active_piece_drop']}, "
            f"volatility drop {metrics['volatility_drop_cp']:.1f}cp"
        )
    if kind == "freeze":
        return (
            f"CoD.freeze: structure {metrics['structure_gain']:+.2f}, "
            f"opp mobilityΔ {metrics['opp_mobility_drop']:+.0f}, tensionΔ {metrics['tension_delta']:+.0f}"
        )
    if kind == "king_safety":
        return (
            f"CoD.king_safety: king safety {metrics['king_safety_gain']:+.2f}, "
            f"opp tacticsΔ {metrics['opp_tactics_change_eval']:+.2f}"
        )
    if kind == "prophylaxis":
        return (
            "CoD.prophylaxis: preventive move dampened dynamics "
            f"(volatility drop {metrics['volatility_drop_cp']:.1f}cp, "
            f"opp mobilityΔ {metrics['opp_mobility_drop']:+.0f})"
        )
    return "control_over_dynamics"


# ===================== 引擎接口 =====================

# ===================== Control over Dynamics v2 helpers =====================


def _cod_gate(ctx: Dict[str, Any], **entries: Any) -> Dict[str, Any]:
    gate = dict(entries)
    return gate


def detect_cod_simplify(ctx: Dict[str, Any], cfg: Dict[str, Any]) -> Tuple[Optional[Dict[str, Any]], Dict[str, Any]]:
    if not ctx.get("allow_positional", False):
        return None, {}
    phase_adjust = phase_bonus(ctx, cfg)
    vol_threshold = cfg.get("VOLATILITY_DROP_CP", CONTROL_VOLATILITY_DROP_CP) + phase_adjust["VOL_BONUS"]
    tension_threshold = cfg.get("TENSION_DEC_MIN", CONTROL_TENSION_DELTA)
    mobility_threshold = cfg.get("OP_MOBILITY_DROP", CONTROL_OPP_MOBILITY_DROP)

    strict_mode = bool(ctx.get("strict_mode"))
    captures_this_ply = ctx.get("captures_this_ply", 0)
    square_defended_by_opp = ctx.get("square_defended_by_opp", 0)
    has_followup = ctx.get("has_immediate_tactical_followup", False)
    expected_recapture_pairs = 1 if ctx.get("is_capture", False) and square_defended_by_opp >= 1 and not has_followup else 0

    total_active_drop = ctx.get("total_active_drop")
    if total_active_drop is None:
        own_drop = ctx.get("own_active_drop", 0)
        opp_drop = ctx.get("opp_active_drop", 0)
        total_active_drop = max(0, (own_drop or 0)) + max(0, (opp_drop or 0))

    exchange_pairs = min(2, captures_this_ply + expected_recapture_pairs)
    exchange_count = ctx.get("exchange_count", 0)
    transaction_ok = (
        exchange_pairs >= 1
        or exchange_count >= 1
        or (total_active_drop or 0) >= 1
    )
    if strict_mode and exchange_pairs < max(2, cfg.get("SIMPLIFY_MIN_EXCHANGE", CONTROL_SIMPLIFY_MIN_EXCHANGE)) and exchange_count < 1:
        transaction_ok = False

    volatility_drop = ctx.get("volatility_drop_cp", 0.0)
    tension_delta = ctx.get("tension_delta", 0.0)
    opp_mobility_drop = ctx.get("opp_mobility_drop", 0.0)
    env_ok = (
        volatility_drop >= vol_threshold
        and tension_delta <= tension_threshold
        and opp_mobility_drop >= mobility_threshold * 0.8
    )

    material_delta_self_cp = ctx.get("material_delta_self_cp")
    if material_delta_self_cp is None:
        material_delta_self_cp = int(round(ctx.get("material_delta_self", 0.0) * 100))
    captured_value_cp = ctx.get("captured_value_cp", 0)
    if expected_recapture_pairs:
        window_cp = max(30, int(round(captured_value_cp * 1.1)))
    else:
        window_cp = 30
    material_ok = abs(material_delta_self_cp or 0) <= window_cp

    gate = _cod_gate(
        ctx,
        subtype="simplify",
        is_capture=ctx.get("is_capture", False),
        expected_recapture_pairs=expected_recapture_pairs,
        exchange_pairs=exchange_pairs,
        exchange_count=exchange_count,
        captures_this_ply=captures_this_ply,
        square_defended_by_opp=square_defended_by_opp,
        total_active_drop=total_active_drop,
        own_active_drop=ctx.get("own_active_drop", 0),
        opp_active_drop=ctx.get("opp_active_drop", 0),
        has_tactical_followup=has_followup,
        volatility_drop=volatility_drop,
        volatility_threshold=vol_threshold,
        tension_delta=tension_delta,
        tension_threshold=tension_threshold,
        opp_mobility_drop=opp_mobility_drop,
        mobility_threshold=mobility_threshold,
        strict_mode=strict_mode,
        material_delta_cp=material_delta_self_cp,
        captured_value_cp=captured_value_cp,
        material_window_cp=window_cp,
    )
    passed = env_ok and transaction_ok and material_ok
    gate["passed"] = passed
    if not passed:
        return None, gate
    capture_type = ctx.get("captured_piece_type")
    captured_label = chess.piece_name(capture_type) if capture_type else "trade"
    metrics = {
        "volatility_drop_cp": volatility_drop,
        "opp_mobility_drop": opp_mobility_drop,
        "tension_delta": tension_delta,
        "exchange_pairs": exchange_pairs,
        "expected_recapture_pairs": expected_recapture_pairs,
        "total_active_drop": total_active_drop,
        "material_delta_self_cp": material_delta_self_cp or 0,
    }
    score = (
        volatility_drop
        + max(0, opp_mobility_drop) * 10
        + exchange_pairs * 40
        - abs(tension_delta) * 2
    )
    why = reason(
        ctx,
        f"{captured_label} exchange_pairs={exchange_pairs}, "
        f"totalActiveDrop={total_active_drop}; vol {volatility_drop:.1f}cp, "
        f"tensionΔ {tension_delta:+.1f}, opMobΔ {opp_mobility_drop:+.1f}"
    )
    candidate = {
        "name": "simplify",
        "metrics": metrics,
        "why": why,
        "score": score,
        "gate": gate,
    }
    return candidate, gate


def detect_cod_plan_kill(ctx: Dict[str, Any], cfg: Dict[str, Any]) -> Tuple[Optional[Dict[str, Any]], Dict[str, Any]]:
    preventive_score = ctx.get("preventive_score", 0.0)
    threat_delta = ctx.get("threat_delta", 0.0)
    plan_drop = bool(ctx.get("plan_drop_passed"))
    break_delta = ctx.get("break_candidates_delta", 0.0)
    mobility_drop = ctx.get("opp_mobility_drop", 0.0)
    volatility_drop = ctx.get("volatility_drop_cp", 0.0)
    tension_delta = ctx.get("tension_delta", 0.0)
    bonus = phase_bonus(ctx, cfg)
    mob_base = cfg.get("OP_MOBILITY_DROP", CONTROL_OPP_MOBILITY_DROP)
    vol_base = cfg.get("VOLATILITY_DROP_CP", CONTROL_VOLATILITY_DROP_CP)
    mob_threshold = mob_base + bonus["OP_MOB_DROP"]
    vol_threshold = vol_base + bonus["VOL_BONUS"]
    gate = _cod_gate(
        ctx,
        subtype="plan_kill",
        plan_drop=plan_drop,
        preventive_score=preventive_score,
        threat_delta=threat_delta,
        mobility_drop=mobility_drop,
        volatility_drop=volatility_drop,
        tension_delta=tension_delta,
        break_candidates_delta=break_delta,
        mobility_threshold=mob_threshold,
        volatility_threshold=vol_threshold,
    )
    plan_gate = False
    if plan_drop:
        if cfg.get("PLAN_KILL_STRICT", True):
            plan_gate = (break_delta <= -1.0) and (mobility_drop >= mob_threshold)
        else:
            plan_gate = (break_delta <= -1.0) or (mobility_drop >= mob_threshold)
        if cfg.get("VOL_GATE_FOR_PLAN", True):
            vol_drop_value = ctx.get("vol_drop_cp", volatility_drop)
            plan_gate = plan_gate and (vol_drop_value >= vol_threshold)
    trigger = PROPHYLAXIS_PREVENTIVE_TRIGGER
    fallback = (
        ctx.get("allow_positional", False)
        and preventive_score >= trigger
        and (
            threat_delta >= PROPHYLAXIS_THREAT_DROP
            or mobility_drop >= mob_base
            or volatility_drop >= vol_base * 0.75
        )
    )
    passed = plan_gate or fallback
    gate["plan_gate"] = plan_gate
    gate["passed"] = passed
    if not passed:
        return None, gate
    source = "plan drop" if plan_drop else "preventive squeeze"
    why = reason(
        ctx,
        f"{source} killed opponent plan (preventive {preventive_score:+.2f}, threatΔ {threat_delta:+.2f})",
    )
    metrics = {
        "preventive_score": preventive_score,
        "threat_delta": threat_delta,
        "opp_mobility_drop": mobility_drop,
        "volatility_drop_cp": volatility_drop,
        "break_candidates_delta": break_delta,
    }
    score = preventive_score * 120 + max(mobility_drop, 0.0) * 20 + (10 if plan_drop else 0)
    candidate = {
        "name": "plan_kill",
        "metrics": metrics,
        "why": why,
        "score": score,
        "gate": gate,
    }
    return candidate, gate


def detect_cod_freeze_bind(ctx: Dict[str, Any], cfg: Dict[str, Any]) -> Tuple[Optional[Dict[str, Any]], Dict[str, Any]]:
    if not ctx.get("allow_positional", False):
        return None, {}
    tension_delta = ctx.get("tension_delta", 0.0)
    contact_ratio_drop = ctx.get("contact_ratio_drop", 0.0)
    op_pins_inc = ctx.get("op_pins_increase", 0)
    opp_mob_drop = ctx.get("opp_mobility_drop", 0.0)
    vol_drop = ctx.get("volatility_drop_cp", 0.0)
    vol_drop_alias = ctx.get("vol_drop_cp", vol_drop)
    phase_adjust = phase_bonus(ctx, cfg)
    vol_threshold = cfg.get("VOLATILITY_DROP_CP", CONTROL_VOLATILITY_DROP_CP) + phase_adjust["VOL_BONUS"]
    mob_threshold = cfg.get("OP_MOBILITY_DROP", CONTROL_OPP_MOBILITY_DROP)
    gate = _cod_gate(
        ctx,
        subtype="freeze_bind",
        tension_delta=tension_delta,
        contact_ratio_drop=contact_ratio_drop,
        op_pins_increase=op_pins_inc,
        opp_mobility_drop=opp_mob_drop,
        volatility_drop_cp=vol_drop_alias,
        mobility_threshold=mob_threshold,
        volatility_threshold=vol_threshold,
    )
    t_ok = (tension_delta <= 0.0) or (contact_ratio_drop <= -0.05)
    p_ok = (op_pins_inc >= 1) or (opp_mob_drop >= mob_threshold)
    env_ok = vol_drop_alias >= vol_threshold
    passed = t_ok and p_ok and env_ok
    gate.update({"t_ok": t_ok, "p_ok": p_ok, "env_ok": env_ok, "passed": passed})
    if not passed:
        return None, gate
    metrics = {
        "tension_delta": tension_delta,
        "contact_ratio_drop": contact_ratio_drop,
        "opp_mobility_drop": opp_mob_drop,
        "op_pins_increase": op_pins_inc,
        "volatility_drop_cp": vol_drop_alias,
    }
    why = reason(
        ctx,
        f"froze bind: tensionΔ {tension_delta:+.1f}, contact ratio {contact_ratio_drop:+.2f}, "
        f"opp mobilityΔ {opp_mob_drop:+.1f}",
    )
    score = max(-tension_delta, 0.0) * 40 + max(opp_mob_drop, 0.0) * 30 + op_pins_inc * 20
    candidate = {
        "name": "freeze_bind",
        "metrics": metrics,
        "why": why,
        "score": score,
        "gate": gate,
    }
    return candidate, gate


def detect_cod_blockade_passed(ctx: Dict[str, Any], cfg: Dict[str, Any]) -> Tuple[Optional[Dict[str, Any]], Dict[str, Any]]:
    opp_passed_exists = ctx.get("opp_passed_exists", False)
    blockade_established = ctx.get("blockade_established", False)
    push_drop = ctx.get("opp_passed_push_drop", 0.0)
    see_support = bool(ctx.get("blockade_front_square_see_non_positive"))
    min_drop = float(cfg.get("PASSED_PUSH_MIN", CONTROL_DEFAULTS["PASSED_PUSH_MIN"]))
    push_ok = push_drop >= min_drop
    if cfg.get("ALLOW_SEE_BLOCKADE", True):
        push_ok = push_ok or see_support
    gate = _cod_gate(
        ctx,
        subtype="blockade_passed",
        opp_passed_exists=opp_passed_exists,
        blockade_established=blockade_established,
        push_drop=push_drop,
        push_threshold=min_drop,
        see_non_positive=see_support,
        push_ok=push_ok,
    )
    passed = opp_passed_exists and blockade_established and push_ok
    gate["passed"] = passed
    if not passed:
        return None, gate
    metrics = {
        "opp_passed_push_drop": push_drop,
        "blockade_file": ctx.get("blockade_file"),
        "see_non_positive": see_support,
    }
    file_label = ctx.get("blockade_file") or ""
    support_note = " (SEE≤0)" if see_support else ""
    why = reason(ctx, f"blockaded passed pawn{(' on ' + file_label) if file_label else ''}{support_note}")
    score = push_drop * 50
    candidate = {
        "name": "blockade_passed",
        "metrics": metrics,
        "why": why,
        "score": score,
        "gate": gate,
    }
    return candidate, gate


def detect_cod_file_seal(ctx: Dict[str, Any], cfg: Dict[str, Any]) -> Tuple[Optional[Dict[str, Any]], Dict[str, Any]]:
    pressure_drop = ctx.get("opp_line_pressure_drop", 0.0)
    break_delta = ctx.get("break_candidates_delta", 0.0)
    mobility_drop = ctx.get("opp_mobility_drop", 0.0)
    vol_drop = ctx.get("volatility_drop_cp", 0.0)
    line_min = float(cfg.get("LINE_MIN", CONTROL_DEFAULTS["LINE_MIN"]))
    gate = _cod_gate(
        ctx,
        subtype="file_seal",
        opp_line_pressure_drop=pressure_drop,
        break_candidates_delta=break_delta,
        mobility_drop=mobility_drop,
        line_min=line_min,
        volatility_drop=vol_drop,
    )
    passed = (
        pressure_drop >= line_min
        or break_delta <= -1.0
    )
    passed = passed and vol_drop >= cfg.get("VOLATILITY_DROP_CP", CONTROL_VOLATILITY_DROP_CP) * 0.5
    gate["passed"] = passed
    if not passed:
        return None, gate
    metrics = {
        "opp_line_pressure_drop": pressure_drop,
        "break_candidates_delta": break_delta,
        "opp_mobility_drop": mobility_drop,
        "volatility_drop_cp": vol_drop,
    }
    why = reason(ctx, f"sealed file, pressure drop {pressure_drop:.1f}, break lanes Δ {break_delta:+.1f}")
    score = pressure_drop * 40 + max(-break_delta, 0.0) * 25
    candidate = {
        "name": "file_seal",
        "metrics": metrics,
        "why": why,
        "score": score,
        "gate": gate,
    }
    return candidate, gate


def detect_cod_king_safety_shell(ctx: Dict[str, Any], cfg: Dict[str, Any]) -> Tuple[Optional[Dict[str, Any]], Dict[str, Any]]:
    ks_gain = ctx.get("king_safety_gain", 0.0)
    opp_tactics = ctx.get("opp_tactics_change_eval", 0.0)
    mobility_drop = ctx.get("opp_mobility_drop", 0.0)
    threshold = float(cfg.get("KS_MIN", CONTROL_DEFAULTS["KS_MIN"])) / 100.0
    gate = _cod_gate(
        ctx,
        subtype="king_safety_shell",
        king_safety_gain=ks_gain,
        opp_tactics=opp_tactics,
        opp_mobility_drop=mobility_drop,
        king_safety_threshold=threshold,
    )
    passed = (
        ks_gain >= threshold
        and (
            opp_tactics <= -0.1
            or mobility_drop >= cfg.get("OP_MOBILITY_DROP", CONTROL_OPP_MOBILITY_DROP)
        )
    )
    gate["passed"] = passed
    if not passed:
        return None, gate
    metrics = {
        "king_safety_gain": ks_gain,
        "opp_tactics_change_eval": opp_tactics,
        "opp_mobility_drop": mobility_drop,
    }
    why = reason(ctx, f"king shelter improved {ks_gain:+.2f}, opp tactics {opp_tactics:+.2f}")
    score = ks_gain * 100 + abs(min(opp_tactics, 0.0)) * 40
    candidate = {
        "name": "king_safety_shell",
        "metrics": metrics,
        "why": why,
        "score": score,
        "gate": gate,
    }
    return candidate, gate


def detect_cod_space_clamp(ctx: Dict[str, Any], cfg: Dict[str, Any]) -> Tuple[Optional[Dict[str, Any]], Dict[str, Any]]:
    if not ctx.get("allow_positional", False):
        return None, {}
    own_space_gain = ctx.get("own_space_gain", ctx.get("space_gain", 0.0))
    space_control_gain = ctx.get("space_control_gain", 0.0)
    mobility_drop = ctx.get("opp_mobility_drop", 0.0)
    tension_delta = ctx.get("tension_delta", 0.0)
    vol_drop_alias = ctx.get("vol_drop_cp", ctx.get("volatility_drop_cp", 0.0))
    phase_adjust = phase_bonus(ctx, cfg)
    space_threshold = float(cfg.get("SPACE_MIN", CONTROL_DEFAULTS["SPACE_MIN"])) / 10.0
    mob_threshold = cfg.get("OP_MOBILITY_DROP", CONTROL_OPP_MOBILITY_DROP)
    vol_threshold = cfg.get("VOLATILITY_DROP_CP", CONTROL_VOLATILITY_DROP_CP) + phase_adjust["VOL_BONUS"]
    gate = _cod_gate(
        ctx,
        subtype="space_clamp",
        space_gain=own_space_gain,
        space_control_gain=space_control_gain,
        opp_mobility_drop=mobility_drop,
        tension_delta=tension_delta,
        volatility_drop_cp=vol_drop_alias,
        space_threshold=space_threshold,
        mobility_threshold=mob_threshold,
        volatility_threshold=vol_threshold,
    )
    space_ok = (own_space_gain >= space_threshold) or (space_control_gain >= 1)
    tension_ok = tension_delta in (0, -1, -2)
    mob_ok = mobility_drop >= mob_threshold
    env_ok = vol_drop_alias >= vol_threshold
    passed = space_ok and mob_ok and tension_ok and env_ok
    gate.update(
        {
            "space_ok": space_ok,
            "tension_ok": tension_ok,
            "mobility_ok": mob_ok,
            "env_ok": env_ok,
            "passed": passed,
        }
    )
    if not passed:
        return None, gate
    metrics = {
        "space_gain": own_space_gain,
        "space_control_gain": space_control_gain,
        "opp_mobility_drop": mobility_drop,
        "tension_delta": tension_delta,
        "volatility_drop_cp": vol_drop_alias,
    }
    why = reason(
        ctx,
        f"space clamp {own_space_gain:+.2f} (controlΔ {space_control_gain:+.0f}) "
        f"opp mobilityΔ {mobility_drop:+.1f}",
    )
    score = own_space_gain * 80 + max(space_control_gain, 0.0) * 10 + mobility_drop * 10
    candidate = {
        "name": "space_clamp",
        "metrics": metrics,
        "why": why,
        "score": score,
        "gate": gate,
    }
    return candidate, gate


def detect_cod_regroup_consolidate(ctx: Dict[str, Any], cfg: Dict[str, Any]) -> Tuple[Optional[Dict[str, Any]], Dict[str, Any]]:
    ks_gain = ctx.get("king_safety_gain", 0.0)
    structure_gain = ctx.get("structure_gain", 0.0)
    self_mobility_change = ctx.get("self_mobility_change", 0.0)
    vol_drop = ctx.get("volatility_drop_cp", 0.0)
    gate = _cod_gate(
        ctx,
        subtype="regroup_consolidate",
        king_safety_gain=ks_gain,
        structure_gain=structure_gain,
        self_mobility_change=self_mobility_change,
        volatility_drop=vol_drop,
    )
    passed = (
        ctx.get("allow_positional", False)
        and vol_drop >= cfg.get("VOLATILITY_DROP_CP", CONTROL_VOLATILITY_DROP_CP) * 0.6
        and self_mobility_change <= 0.05
        and (ks_gain >= 0.05 or structure_gain >= 0.1)
    )
    gate["passed"] = passed
    if not passed:
        return None, gate
    metrics = {
        "king_safety_gain": ks_gain,
        "structure_gain": structure_gain,
        "volatility_drop_cp": vol_drop,
    }
    why = reason(ctx, f"regrouped to consolidate safety ({ks_gain:+.2f}) and structure ({structure_gain:+.2f})")
    score = vol_drop + ks_gain * 80 + structure_gain * 60
    candidate = {
        "name": "regroup_consolidate",
        "metrics": metrics,
        "why": why,
        "score": score,
        "gate": gate,
    }
    return candidate, gate


def detect_cod_slowdown(ctx: Dict[str, Any], cfg: Dict[str, Any]) -> Tuple[Optional[Dict[str, Any]], Dict[str, Any]]:
    if not ctx.get("allow_positional", False):
        return None, {}
    has_dynamic = ctx.get("has_dynamic_in_band", False)
    played_kind = ctx.get("played_kind")
    eval_drop_cp = ctx.get("eval_drop_cp", 0)
    vol_bonus = phase_bonus(ctx, cfg)["VOL_BONUS"]
    mob_bonus = phase_bonus(ctx, cfg)["OP_MOB_DROP"]
    vol_threshold = cfg.get("VOLATILITY_DROP_CP", CONTROL_VOLATILITY_DROP_CP) + vol_bonus
    mob_threshold = cfg.get("OP_MOBILITY_DROP", CONTROL_OPP_MOBILITY_DROP) + mob_bonus
    phase_bucket = ctx.get("phase_bucket", "middlegame")
    tension_threshold = _control_tension_threshold(phase_bucket)
    tension_delta = ctx.get("tension_delta", 0.0)
    opp_mobility_drop = ctx.get("opp_mobility_drop", 0.0)
    volatility_drop = ctx.get("volatility_drop_cp", 0.0)
    gate = _cod_gate(
        ctx,
        subtype="slowdown",
        has_dynamic=has_dynamic,
        played_kind=played_kind,
        eval_drop_cp=eval_drop_cp,
        eval_threshold=cfg.get("EVAL_DROP_CP", CONTROL_EVAL_DROP),
        volatility_drop=volatility_drop,
        volatility_threshold=vol_threshold,
        tension_delta=tension_delta,
        tension_threshold=tension_threshold,
        opp_mobility_drop=opp_mobility_drop,
        mobility_threshold=mob_threshold,
    )
    passed = (
        has_dynamic
        and played_kind == "positional"
        and eval_drop_cp <= cfg.get("EVAL_DROP_CP", CONTROL_EVAL_DROP)
        and volatility_drop >= vol_threshold
        and tension_delta <= tension_threshold
        and opp_mobility_drop >= mob_threshold
    )
    gate["passed"] = passed
    if not passed:
        return None, gate
    metrics = {
        "eval_drop_cp": eval_drop_cp,
        "volatility_drop_cp": volatility_drop,
        "tension_delta": tension_delta,
        "opp_mobility_drop": opp_mobility_drop,
    }
    why = reason(ctx, f"slowdown dampened dynamics (vol {volatility_drop:.1f}cp, opp mobility {opp_mobility_drop:+.0f})")
    score = volatility_drop + opp_mobility_drop * 5
    candidate = {
        "name": "slowdown",
        "metrics": metrics,
        "why": why,
        "score": score,
        "gate": gate,
    }
    return candidate, gate


COD_DETECTORS = {
    "simplify": detect_cod_simplify,
    "plan_kill": detect_cod_plan_kill,
    "freeze_bind": detect_cod_freeze_bind,
    "blockade_passed": detect_cod_blockade_passed,
    "file_seal": detect_cod_file_seal,
    "king_safety_shell": detect_cod_king_safety_shell,
    "space_clamp": detect_cod_space_clamp,
    "regroup_consolidate": detect_cod_regroup_consolidate,
    "slowdown": detect_cod_slowdown,
}


def select_cod_subtype(
    ctx: Dict[str, Any],
    cfg: Dict[str, Any],
    last_state: Optional[Dict[str, Any]],
) -> Tuple[Optional[Dict[str, Any]], List[str], int, Dict[str, Any], List[Dict[str, Any]]]:
    """Collect detector outputs, apply cooldown, and pick one subtype."""
    phase_name = ctx.get("phase")
    if phase_name == "END":
        priority = list(cfg.get("PRIORITY_END", cfg.get("PRIORITY", COD_SUBTYPES)))
    else:
        priority = list(cfg.get("PRIORITY", COD_SUBTYPES))

    def _gate_compact_score(gate: Dict[str, Any]) -> float:
        if not isinstance(gate, dict):
            return 0.0
        score = 0.0
        if "env_ok" in gate:
            score += 1.0 if gate.get("env_ok") else 0.0
        else:
            vol_value = gate.get("volatility_drop_cp")
            vol_threshold = gate.get("volatility_threshold")
            if vol_value is not None and vol_threshold is not None and vol_value >= vol_threshold:
                score += 1.0
        if "mobility_ok" in gate:
            score += 1.0 if gate.get("mobility_ok") else 0.0
        else:
            mob_value = gate.get("opp_mobility_drop", gate.get("mobility_drop"))
            mob_threshold = gate.get("mobility_threshold")
            if mob_value is not None and mob_threshold is not None and mob_value >= mob_threshold:
                score += 1.0
        if "t_ok" in gate:
            score += 1.0 if gate.get("t_ok") else 0.0
        elif "tension_ok" in gate:
            score += 1.0 if gate.get("tension_ok") else 0.0
        else:
            tension_delta = gate.get("tension_delta")
            tension_threshold = gate.get("tension_threshold")
            if tension_delta is not None and tension_threshold is not None and tension_delta <= tension_threshold:
                score += 1.0
        return score
    gate_log: Dict[str, Any] = {}
    detected: List[Dict[str, Any]] = []
    for subtype in priority:
        detector = COD_DETECTORS.get(subtype)
        if detector is None:
            continue
        candidate, gate = detector(ctx, cfg)
        if gate:
            gate_log[subtype] = gate
        if candidate:
            detected.append(candidate)
    cooldown_plies = int(cfg.get("COOLDOWN_PLIES", CONTROL_COOLDOWN_PLIES))
    current_ply = ctx.get("current_ply")
    cooldown_remaining = 0
    removed_by_cooldown: List[str] = []
    if last_state:
        last_kind = last_state.get("kind")
        last_ply = last_state.get("ply")
        if (
            last_kind
            and isinstance(last_ply, int)
            and isinstance(current_ply, int)
        ):
            diff = current_ply - last_ply
            if diff <= cooldown_plies:
                cooldown_remaining = max(0, cooldown_plies - diff)
                if detected:
                    remaining: List[Dict[str, Any]] = []
                    for cand in detected:
                        if cand["name"] == last_kind:
                            if last_kind not in removed_by_cooldown:
                                removed_by_cooldown.append(last_kind)
                        else:
                            remaining.append(cand)
                    detected = remaining
    index_map = {name: idx for idx, name in enumerate(priority)}
    detected.sort(key=lambda item: (index_map.get(item["name"], 999), -item.get("score", 0.0)))
    if not detected:
        suppressed = list(removed_by_cooldown)
        return None, suppressed, cooldown_remaining, gate_log, []
    rare_types: Set[str] = set(cfg.get("RARE_TYPES", []))
    phase_weights_cfg = cfg.get("PHASE_WEIGHTS", {})
    phase_key = phase_name if isinstance(phase_name, str) else ctx.get("phase")
    phase_weights = phase_weights_cfg.get(phase_key, {})
    tie_delta = float(cfg.get("TIE_BREAK_DELTA", 0.0))
    eval_info: List[Dict[str, Any]] = []
    for idx, candidate in enumerate(detected):
        name = candidate.get("name")
        priority_rank = index_map.get(name, len(priority))
        phase_weight = float(phase_weights.get(name, 0.0)) if isinstance(phase_weights, dict) else 0.0
        gate_score = _gate_compact_score(candidate.get("gate", {}))
        composite = float(priority_rank) - phase_weight - gate_score
        eval_info.append(
            {
                "index": idx,
                "candidate": candidate,
                "name": name,
                "priority_rank": priority_rank,
                "phase_weight": phase_weight,
                "gate_score": gate_score,
                "composite": composite,
                "is_rare": name in rare_types,
            }
        )
    selected_index = 0
    best_entry = eval_info[0]
    rare_candidates = [info for info in eval_info if info["is_rare"]]
    if rare_candidates and not best_entry["is_rare"]:
        rare_best = min(rare_candidates, key=lambda info: info["composite"])
        gate_gap = abs(best_entry["gate_score"] - rare_best["gate_score"])
        if (
            rare_best["phase_weight"] > 0.0
            and gate_gap <= 1.0
            and rare_best["composite"] <= best_entry["composite"] + tie_delta
        ):
            selected_index = rare_best["index"]
            if selected_index != 0:
                selected_candidate = detected.pop(selected_index)
                detected.insert(0, selected_candidate)
                selected_index = 0
    selected = detected[selected_index]
    suppressed = [entry["name"] for idx, entry in enumerate(detected) if idx != selected_index]
    for name in removed_by_cooldown:
        if name not in suppressed:
            suppressed.append(name)
    return selected, suppressed, cooldown_remaining, gate_log, detected


# ===================== 标签判定主函数 =====================

def tag_position(
    engine_path: str,
    fen: str,
    played_move_uci: str,
    depth: int = 14,
    multipv: int = 6,
    cp_threshold: int = 100,
    small_drop_cp: int = 30
) -> TagResult:
    control_cfg, control_enabled, control_strict = _resolve_control_config()
    if not control_enabled:
        return legacy_tag_position_v8(
            engine_path,
            fen,
            played_move_uci,
            depth=depth,
            multipv=multipv,
            cp_threshold=cp_threshold,
            small_drop_cp=small_drop_cp,
        )
    board = chess.Board(fen)
    actor = board.turn
    metrics_before, opp_metrics_before, evaluation_before = evaluation_and_metrics(board, actor)
    coverage_before = defended_square_count(board, actor)
    played_move = parse_move(board, played_move_uci)

    candidates, eval_before_cp, analysis_meta = analyse_candidates(
        engine_path, board, depth=depth, multipv=multipv
    )
    if not candidates:
        raise RuntimeError("Engine returned no candidates.")

    phase_ratio = analysis_meta.get("phase_ratio", estimate_phase_ratio(board))

    best = candidates[0]
    in_band = [c for c in candidates if (best.score_cp - c.score_cp) <= cp_threshold]

    played_entry: Optional[Candidate] = next((c for c in in_band if c.move == played_move), None)
    if played_entry is None:
        played_score_cp = eval_specific_move(engine_path, board, played_move, depth=depth)
        played_kind = classify_move(board, played_move)
    else:
        played_score_cp = played_entry.score_cp
        played_kind = played_entry.kind

    eval_before = round(eval_before_cp / 100.0, 2)
    eval_played = round(played_score_cp / 100.0, 2)
    eval_best = round(best.score_cp / 100.0, 2)
    delta_eval = round((best.score_cp - played_score_cp) / 100.0, 2)
    eval_played_cp = played_score_cp
    eval_best_cp = best.score_cp

    has_dynamic_in_band = any(c.kind == "dynamic" for c in in_band)

    played_board = board.copy(stack=False)
    played_board.push(played_move)
    metrics_played, opp_metrics_played, evaluation_played = evaluation_and_metrics(played_board, actor)
    coverage_after = defended_square_count(played_board, actor)

    best_board = board.copy(stack=False)
    best_board.push(best.move)
    metrics_best, opp_metrics_best, evaluation_best = evaluation_and_metrics(best_board, actor)
    coverage_best = defended_square_count(best_board, actor)

    contact_ratio_before, _, _, _ = contact_profile(board)
    contact_ratio_played, _, _, _ = contact_profile(played_board)
    contact_ratio_best, _, _, _ = contact_profile(best_board)
    contact_delta_played = contact_ratio_played - contact_ratio_before
    contact_delta_best = contact_ratio_best - contact_ratio_before
    analysis_meta.setdefault("tension_support", {})
    analysis_meta["tension_support"].update(
        {
            "contact_ratio_before": round(contact_ratio_before, 3),
            "contact_ratio_played": round(contact_ratio_played, 3),
            "contact_ratio_best": round(contact_ratio_best, 3),
            "contact_delta_played": round(contact_delta_played, 3),
            "contact_delta_best": round(contact_delta_best, 3),
            "thresholds": {
                "tension_mobility_min": TENSION_MOBILITY_THRESHOLD,
                "tension_mobility_near": TENSION_MOBILITY_NEAR,
                "contact_ratio_min": TENSION_CONTACT_JUMP,
                "contact_ratio_delay": TENSION_CONTACT_DELAY,
                "tension_mobility_delay": TENSION_MOBILITY_DELAY,
                "tension_trend_self": TENSION_TREND_SELF,
                "tension_trend_opp": TENSION_TREND_OPP,
            },
        }
    )

    component_deltas = metrics_delta(metrics_played, metrics_best)
    change_played_vs_before = metrics_delta(metrics_before, metrics_played)
    opp_component_deltas = metrics_delta(opp_metrics_played, opp_metrics_best)
    opp_change_played_vs_before = metrics_delta(opp_metrics_before, opp_metrics_played)
    self_vs_best = {key: round(-component_deltas[key], 3) for key in STYLE_COMPONENT_KEYS}
    opp_vs_best = {key: round(-opp_component_deltas[key], 3) for key in STYLE_COMPONENT_KEYS}
    coverage_delta = coverage_after - coverage_before

    followup_steps = 3

    def _compute_delta_sequence(base: Dict[str, float], sequence: List[Dict[str, float]]) -> List[Dict[str, float]]:
        deltas: List[Dict[str, float]] = []
        for metrics in sequence:
            deltas.append({key: round(metrics[key] - base[key], 3) for key in STYLE_COMPONENT_KEYS})
        return deltas

    with chess.engine.SimpleEngine.popen_uci(engine_path) as follow_engine:
        base_self_before, base_opp_before, seq_self_before, seq_opp_before = simulate_followup_metrics(
            follow_engine, board, actor, steps=followup_steps
        )
        base_self_played, base_opp_played, seq_self_played, seq_opp_played = simulate_followup_metrics(
            follow_engine, played_board, actor, steps=followup_steps
        )
        base_self_best, base_opp_best, seq_self_best, seq_opp_best = simulate_followup_metrics(
            follow_engine, best_board, actor, steps=followup_steps
        )

    follow_self_deltas = _compute_delta_sequence(base_self_before, seq_self_played)
    follow_opp_deltas = _compute_delta_sequence(base_opp_before, seq_opp_played)
    follow_self_deltas_best = _compute_delta_sequence(base_self_before, seq_self_best)
    follow_opp_deltas_best = _compute_delta_sequence(base_opp_before, seq_opp_best)

    def _ema_trend(deltas: List[Dict[str, float]]) -> float:
        if not deltas:
            return 0.0
        weights = [0.6, 0.3, 0.1][: len(deltas)]
        total = sum(weights)
        trend = sum(w * deltas[idx]["mobility"] for idx, w in enumerate(weights))
        return trend / total if total else 0.0

    def _window_stats(deltas: List[Dict[str, float]], steps: int = 2) -> Tuple[float, float]:
        if len(deltas) < steps:
            return 0.0, 0.0
        window = deltas[:steps]
        values = [abs(entry["mobility"]) for entry in window]
        mean = sum(values) / len(values)
        variance = sum((val - mean) ** 2 for val in values) / len(values)
        return mean, variance

    self_trend = _ema_trend(follow_self_deltas)
    opp_trend = _ema_trend(follow_opp_deltas)
    self_trend_best = _ema_trend(follow_self_deltas_best)
    opp_trend_best = _ema_trend(follow_opp_deltas_best)
    follow_window_mean, follow_window_var = _window_stats(follow_self_deltas)

    delta_best_vs_before_cp = eval_best_cp - eval_before_cp
    delta_tactics_best_vs_before = (
        evaluation_best["components"]["tactics"] - evaluation_before["components"]["tactics"]
    )
    delta_structure_best_vs_before = (
        evaluation_best["components"]["structure"] - evaluation_before["components"]["structure"]
    )

    best_is_forcing = board.is_capture(best.move) or board.gives_check(best.move)
    played_is_forcing = board.is_capture(played_move) or board.gives_check(played_move)
    analysis_meta["best_is_forcing"] = best_is_forcing
    analysis_meta["played_is_forcing"] = played_is_forcing

    tactical_weight = compute_tactical_weight(
        delta_best_vs_before_cp,
        delta_tactics_best_vs_before,
        delta_structure_best_vs_before,
        analysis_meta["depth_jump_cp"],
        analysis_meta.get("deepening_gain_cp", 0),
        analysis_meta["score_gap_cp"],
        analysis_meta["contact_ratio"],
        analysis_meta.get("phase_ratio", estimate_phase_ratio(board)),
        best_is_forcing,
        played_is_forcing,
        analysis_meta.get("mate_threat", False),
    )

    if tactical_weight >= 0.65:
        mode = "tactical"
    elif tactical_weight <= 0.35:
        mode = "positional"
    else:
        mode = "blended"

    allow_positional = tactical_weight <= 0.7
    allow_tactical = tactical_weight >= 0.3
    allow_structural = True

    notes: Dict[str, str] = {}

    delta_self_mobility = change_played_vs_before["mobility"]
    delta_opp_mobility = opp_change_played_vs_before["mobility"]
    control_over_dynamics = False
    control_over_dynamics_subtype: Optional[str] = None
    cod_flags = {name: False for name in COD_SUBTYPES}
    deferred_initiative = False
    risk_avoidance = False
    prophylactic_move = False
    prophylaxis_pattern_override = False
    prophylaxis_pattern_support = False
    prophylaxis_score = 0.0
    preventive_score = 0.0
    adjusted_preventive = 0.0
    self_safety_bonus = 0.0
    analysis_meta.setdefault("prophylaxis", {})
    analysis_meta["prophylaxis"].setdefault("telemetry", {})
    structural_integrity = False
    structural_compromise_dynamic = False
    structural_compromise_static = False
    tactical_sensitivity = False
    initiative_exploitation = False
    initiative_attempt = False
    tension_creation = False
    neutral_tension_creation = False
    premature_attack = False
    constructive_maneuver = False
    neutral_maneuver = False
    misplaced_maneuver = False
    maneuver_opening = False
    tactical_sacrifice = False
    positional_sacrifice = False
    inaccurate_tactical_sacrifice = False
    speculative_sacrifice = False
    desperate_sacrifice = False
    tactical_combination_sacrifice = False
    tactical_initiative_sacrifice = False
    positional_structure_sacrifice = False
    positional_space_sacrifice = False
    file_pressure_c_flag = False
    first_choice = False
    missed_tactic = False
    conversion_precision = False
    panic_move = False
    tactical_recovery = False
    maneuver_precision_score = 0.0
    maneuver_timing_score = 0.0
    behavior_scores: Dict[str, float] = {}
    plan_drop_result: Optional[PlanDropResult] = None

    delta_eval_cp = best.score_cp - played_score_cp
    delta_eval_played_vs_before = played_score_cp - eval_before_cp
    delta_eval_float = delta_eval_played_vs_before / 100.0
    drop_cp = delta_eval_played_vs_before
    structure_gain = change_played_vs_before["structure"]
    tactics_gain = change_played_vs_before["tactics"]
    center_gain = change_played_vs_before["center_control"]

    tau = compute_tau(eval_before)
    effective_delta = delta_eval_float / max(tau, 1e-6)
    material_before = material_balance(board, actor)
    material_after = material_balance(played_board, actor)
    material_delta_self = round(material_after - material_before, 3)

    analysis_meta.setdefault("material", {})
    analysis_meta["material"].update(
        {
            "before": material_before,
            "after": material_after,
            "delta": material_delta_self,
        }
    )
    analysis_meta.setdefault("context", {})
    analysis_meta["context"].update(
        {
            "tau": round(tau, 3),
            "eval_before": eval_before,
            "eval_delta": delta_eval_float,
            "effective_delta": round(effective_delta, 3),
        }
    )
    control_metrics = _collect_control_metrics(
        board,
        played_board,
        actor,
        played_move,
        phase_ratio,
        delta_eval_cp,
        drop_cp,
        change_played_vs_before,
        opp_change_played_vs_before,
        analysis_meta,
        material_delta_self,
    )
    control_meta = analysis_meta.setdefault("control_dynamics", {})
    control_meta.update(control_metrics)
    control_meta["enabled"] = control_enabled
    control_meta["strict_mode"] = control_strict
    config_snapshot = {
        "volatility_drop_cp": control_cfg.get("VOLATILITY_DROP_CP", CONTROL_VOLATILITY_DROP_CP),
        "opp_mobility_drop": control_cfg.get("OP_MOBILITY_DROP", CONTROL_OPP_MOBILITY_DROP),
        "cooldown_plies": control_cfg.get("COOLDOWN_PLIES", CONTROL_COOLDOWN_PLIES),
    }
    if control_strict:
        strict_deltas = dict(
            control_cfg.get(
                "_strict_deltas",
                {
                    "VOLATILITY_DROP_CP": STRICT_MODE_VOL_DELTA,
                    "OP_MOBILITY_DROP": STRICT_MODE_MOB_DELTA,
                },
            )
        )
        config_snapshot["strict_deltas"] = strict_deltas
    control_meta["config_snapshot"] = config_snapshot
    notes["control_flags"] = f"control_v2 enabled={control_enabled} strict={control_strict}"
    snapshot_parts = [
        f"vol_drop_cp={config_snapshot['volatility_drop_cp']}",
        f"opp_mob_drop={config_snapshot['opp_mobility_drop']}",
        f"cooldown={config_snapshot['cooldown_plies']}",
    ]
    strict_deltas = config_snapshot.get("strict_deltas")
    if strict_deltas:
        vol_delta = strict_deltas.get("VOLATILITY_DROP_CP")
        mob_delta = strict_deltas.get("OP_MOBILITY_DROP")
        snapshot_parts.append(f"strict_delta(vol={vol_delta},mob={mob_delta})")
    notes["control_config_snapshot"] = ", ".join(snapshot_parts)
    ctx = control_meta.setdefault("context", {})
    ctx.clear()
    ctx["enabled"] = control_enabled
    ctx["strict_mode"] = control_strict
    ctx["config_snapshot"] = dict(config_snapshot)
    opp_passed_push_before, blockers_before = _count_passed_push_targets(board, not actor)
    opp_passed_push_after, blockers_after = _count_passed_push_targets(played_board, not actor)
    blockade_established = False
    blockade_file: Optional[str] = None
    moved_piece = board.piece_at(played_move.from_square)
    piece_type = moved_piece.piece_type if moved_piece else None
    moved_to = played_move.to_square
    blocker_entry = blockers_after.get(moved_to)
    blockade_front_see_non_positive = False
    if blocker_entry is not None:
        occupant = played_board.piece_at(moved_to)
        if occupant and occupant.color == actor:
            blockade_established = True
            blockade_file = chess.FILE_NAMES[chess.square_file(blocker_entry)]
            see_probe = getattr(played_board, "see", None)
            block_move = chess.Move(blocker_entry, moved_to)
            try:
                if played_board.is_legal(block_move):
                    if callable(see_probe):
                        try:
                            blockade_front_see_non_positive = float(see_probe(block_move)) <= 0.0
                        except Exception:
                            blockade_front_see_non_positive = False
                    else:
                        blockade_front_see_non_positive = False
                else:
                    # Opponent cannot immediately capture the blocker
                    blockade_front_see_non_positive = True
            except Exception:
                blockade_front_see_non_positive = False
    opp_passed_exists = bool(opp_passed_push_before or blockers_before)
    opp_passed_push_drop = float(opp_passed_push_before - opp_passed_push_after)
    if opp_passed_push_drop < 0:
        opp_passed_push_drop = 0.0
    opp_contact_before = control_metrics.get("opp_contact_before", {})
    opp_contact_after = control_metrics.get("opp_contact_after", {})
    opp_line_pressure_drop = float(
        max(
            0.0,
            (opp_contact_before.get("contact", 0.0) or 0.0)
            - (opp_contact_after.get("contact", 0.0) or 0.0),
        )
    )
    self_contact_before = control_metrics.get("self_contact_before", {})
    self_contact_after = control_metrics.get("self_contact_after", {})
    break_candidates_delta = float(
        (self_contact_after.get("captures", 0.0) or 0.0)
        - (self_contact_before.get("captures", 0.0) or 0.0)
    )
    plan_meta = analysis_meta.setdefault("prophylaxis_plan", {})
    raw_phase_bucket = control_metrics.get("phase_bucket", _phase_bucket(phase_ratio))
    normalized_phase = _normalize_phase_label(raw_phase_bucket)
    ctx.update(
        {
            "eval_drop_cp": delta_eval_cp,
            "vol_drop_cp": control_metrics.get("volatility_drop_cp", 0.0),
            "tension_delta": control_metrics.get("tension_delta", 0.0),
            "op_mob_drop": control_metrics.get("opp_mobility_drop", 0.0),
            "phase": normalized_phase,
            "phase_bucket": raw_phase_bucket,
            "phase_ratio": phase_ratio,
            "allow_positional": allow_positional,
            "has_dynamic_in_band": has_dynamic_in_band,
            "played_kind": played_kind,
            "exchange_count": int(max(0, control_metrics.get("active_piece_drop", 0))),
            "exchanged_rooks": int(
                1 if control_metrics.get("captured_piece_type") == chess.ROOK else 0
            ),
            "plan_drop_passed": bool(plan_meta.get("passed")),
            "prophylaxis_plan_drop": False,
            "prophylaxis_line_seal": False,
            "break_candidates_delta": break_candidates_delta,
            "opp_line_pressure_drop": opp_line_pressure_drop,
            "op_pins_increase": 0,
            "opp_passed_exists": opp_passed_exists,
            "blockade_established": blockade_established,
            "blockade_file": blockade_file,
            "opp_passed_push_drop": opp_passed_push_drop,
            "blockade_front_square_see_non_positive": blockade_front_see_non_positive,
            "king_safety_gain": control_metrics.get("king_safety_gain", 0.0),
            "opp_attackers_drop": 0,
            "own_space_gain": center_gain,
            "loose_pieces_drop": 0,
            "hanging_threats_drop": 0,
            "preventive_score": 0.0,
            "threat_delta": 0.0,
            "king_safety_tolerance": KING_SAFETY_TOLERANCE,
        }
    )
    ctx["strict_mode"] = control_strict
    # Aliases and derived metrics for downstream detectors and diagnostics.
    ctx["volatility_drop_cp"] = ctx["vol_drop_cp"]
    ctx["opp_mobility_drop"] = ctx["op_mob_drop"]
    ctx["self_mobility_change"] = control_metrics.get("self_mobility_change", 0.0)
    ctx["opp_mobility_change_eval"] = control_metrics.get("opp_mobility_change_eval", 0.0)
    ctx["opp_tactics_change_eval"] = control_metrics.get("opp_tactics_change_eval", 0.0)
    ctx["structure_gain"] = control_metrics.get("structure_gain", 0.0)
    ctx["center_gain"] = control_metrics.get("center_gain", center_gain)
    ctx["space_gain"] = ctx["own_space_gain"]
    ctx["space_control_gain"] = coverage_delta
    ctx["material_delta_self"] = control_metrics.get("material_delta_self", 0.0)
    ctx["material_delta_self_cp"] = control_metrics.get("material_delta_self_cp", 0)
    ctx["captured_value_cp"] = control_metrics.get("captured_value_cp", 0)
    ctx["captured_piece_type"] = control_metrics.get("captured_piece_type")
    ctx["is_capture"] = control_metrics.get("is_capture", False)
    ctx["active_piece_drop"] = control_metrics.get("active_piece_drop", 0)
    ctx["own_active_drop"] = control_metrics.get("own_active_drop", 0)
    ctx["opp_active_drop"] = control_metrics.get("opp_active_drop", 0)
    ctx["op_active_drop"] = ctx["opp_active_drop"]
    ctx["total_active_drop"] = control_metrics.get("total_active_drop", ctx["active_piece_drop"])
    ctx["captures_this_ply"] = control_metrics.get("captures_this_ply", 0)
    ctx["square_defended_by_opp"] = control_metrics.get("square_defended_by_opp", 0)
    ctx["square_defended_by_self"] = control_metrics.get("square_defended_by_self", 0)
    ctx["contact_ratio_before"] = control_metrics.get("self_contact_before", {}).get("ratio", 0.0)
    ctx["contact_ratio_after"] = control_metrics.get("self_contact_after", {}).get("ratio", 0.0)
    ctx["contact_ratio_drop"] = ctx["contact_ratio_after"] - ctx["contact_ratio_before"]
    ctx["opp_contact_ratio_before"] = control_metrics.get("opp_contact_before", {}).get("ratio", 0.0)
    ctx["opp_contact_ratio_after"] = control_metrics.get("opp_contact_after", {}).get("ratio", 0.0)
    ctx["volatility_before_cp"] = control_metrics.get("volatility_before_cp", 0.0)
    ctx["volatility_after_cp"] = control_metrics.get("volatility_after_cp", 0.0)
    ctx["played_move"] = played_move.uci()
    ctx["played_piece_type"] = piece_type

    intent_label, intent_signals = infer_intent_hint(
        delta_self_mobility,
        delta_opp_mobility,
        change_played_vs_before["king_safety"],
        center_gain,
        contact_delta_played,
        delta_eval_float,
    )
    analysis_meta.setdefault("intent_hint", {})
    analysis_meta["intent_hint"].update(
        {"label": intent_label, "signals": intent_signals}
    )
    ctx["tactical_weight"] = tactical_weight
    has_immediate_tactical_followup = bool(
        analysis_meta.get("played_is_forcing")
        or analysis_meta.get("mate_threat")
        or (tactical_weight >= 0.6 and ctx.get("has_dynamic_in_band", False))
    )
    ctx["has_immediate_tactical_followup"] = has_immediate_tactical_followup
    restriction_candidate = (
        intent_label == "restriction"
        and delta_opp_mobility <= -PLAN_DROP_OPP_MOBILITY_GATE
        and change_played_vs_before["king_safety"] >= 0.0
        and mode != "tactical"
    )
    passive_candidate = (
        intent_label == "passive"
        and (
            delta_eval_float <= PASSIVE_PLAN_EVAL_DROP
            or (
                delta_self_mobility <= PASSIVE_PLAN_MOBILITY_SELF
                and delta_opp_mobility >= PASSIVE_PLAN_MOBILITY_OPP
            )
        )
        and mode != "tactical"
    )
    plan_candidate = restriction_candidate or passive_candidate
    intent_meta = analysis_meta["intent_hint"]
    intent_meta["restriction_candidate"] = restriction_candidate
    intent_meta["passive_candidate"] = passive_candidate

    mover_piece = board.piece_at(played_move.from_square)
    is_pawn_move = bool(mover_piece and mover_piece.piece_type == chess.PAWN)
    is_center_pawn_push = bool(
        is_pawn_move
        and chess.square_file(played_move.to_square) in CENTER_FILES
        and chess.square_file(played_move.from_square) in CENTER_FILES
    )

    plan_meta.update(
        {
            "candidate": plan_candidate,
            "restriction_candidate": restriction_candidate,
            "passive_candidate": passive_candidate,
            "psi_threshold": PLAN_DROP_PSI_MIN,
            "plan_loss_threshold": PLAN_DROP_PLAN_LOSS_MIN,
            "eval_drop_cap": PLAN_DROP_EVAL_CAP,
        }
    )

    side_key = "white" if actor == chess.WHITE else "black"
    pawn_struct_before = evaluation_before["pawn_structure"][side_key]
    pawn_struct_played = evaluation_played["pawn_structure"][side_key]
    pawn_struct_best = evaluation_best["pawn_structure"][side_key]

    delta_isolated = len(pawn_struct_played["isolated_pawns"]) - len(pawn_struct_before["isolated_pawns"])
    delta_doubled = len(pawn_struct_played["doubled_pawns"]) - len(pawn_struct_before["doubled_pawns"])
    delta_backward_raw = len(pawn_struct_played["backward_pawns"]) - len(pawn_struct_before["backward_pawns"])
    delta_backward, backward_added = backward_delta(
        pawn_struct_before["backward_pawns"],
        pawn_struct_played["backward_pawns"],
        played_move,
        actor,
        played_board,
        contact_delta_played,
    )
    delta_islands = pawn_struct_played["pawn_islands"] - pawn_struct_before["pawn_islands"]
    delta_chains = len(pawn_struct_played["pawn_chains"]) - len(pawn_struct_before["pawn_chains"])

    delta_isolated_best = len(pawn_struct_best["isolated_pawns"]) - len(pawn_struct_before["isolated_pawns"])
    delta_doubled_best = len(pawn_struct_best["doubled_pawns"]) - len(pawn_struct_before["doubled_pawns"])
    delta_backward_best, backward_added_best = backward_delta(
        pawn_struct_before["backward_pawns"],
        pawn_struct_best["backward_pawns"],
        best.move,
        actor,
        best_board,
        contact_delta_best,
    )
    delta_islands_best = pawn_struct_best["pawn_islands"] - pawn_struct_before["pawn_islands"]
    delta_chains_best = len(pawn_struct_best["pawn_chains"]) - len(pawn_struct_before["pawn_chains"])

    king_before = evaluation_before["king_safety"][side_key]
    king_played = evaluation_played["king_safety"][side_key]
    king_best = evaluation_best["king_safety"][side_key]
    delta_shield = king_played["pawn_shield"] - king_before["pawn_shield"]
    delta_shield_best = king_best["pawn_shield"] - king_before["pawn_shield"]

    structural_counts_before = {
        "isolated": len(pawn_struct_before["isolated_pawns"]),
        "doubled": len(pawn_struct_before["doubled_pawns"]),
        "backward": len(pawn_struct_before["backward_pawns"]),
        "islands": pawn_struct_before["pawn_islands"],
        "chains": len(pawn_struct_before["pawn_chains"]),
        "shield": king_before["pawn_shield"],
    }

    structure_score_before = pawn_struct_before["score"]
    structure_score_played = pawn_struct_played["score"]
    structure_score_best = pawn_struct_best["score"]
    structure_score_gain = structure_score_played - structure_score_before
    structure_score_gain_best = structure_score_best - structure_score_before

    structural_event_details = {
        "isolated": delta_isolated,
        "doubled": delta_doubled,
        "backward": delta_backward,
        "islands": delta_islands,
        "chains": delta_chains,
        "shield": delta_shield,
        "structure_score": round(structure_score_gain, 3),
    }
    structural_event_details_best = {
        "isolated": delta_isolated_best,
        "doubled": delta_doubled_best,
        "backward": delta_backward_best,
        "islands": delta_islands_best,
        "chains": delta_chains_best,
        "shield": delta_shield_best,
        "structure_score": round(structure_score_gain_best, 3),
    }
    structural_event = any(
        [
            delta_isolated > 0,
            delta_doubled > 0,
            delta_backward > 0,
            delta_islands > 0,
            delta_chains < 0,
            delta_shield < 0,
        ]
    )

    structural_event_best = any(
        [
            delta_isolated_best > 0,
            delta_doubled_best > 0,
            delta_backward_best > 0,
            delta_islands_best > 0,
            delta_chains_best < 0,
            delta_shield_best < 0,
        ]
    )

    structural_shift_signal = any(
        [
            delta_isolated != 0,
            delta_doubled != 0,
            delta_backward != 0,
            delta_islands != 0,
            delta_chains != 0,
            delta_shield != 0,
        ]
    ) or abs(structure_score_gain) >= 0.1

    structure_drop_threshold = -0.12 * (1 + 0.3 * phase_ratio)
    if structure_score_gain <= structure_drop_threshold:
        structural_event = True
        structural_event_details.setdefault("structure_drop", round(structure_score_gain, 3))
    if structure_score_gain_best <= structure_drop_threshold:
        structural_event_best = True
        structural_event_details_best.setdefault("structure_drop", round(structure_score_gain_best, 3))

    blockage_threshold = STATIC_BLOCKAGE_THRESHOLD_BASE * (0.6 + 0.4 * phase_ratio)
    blockage_trigger_margin = blockage_threshold + STATIC_BLOCKAGE_MARGIN
    blockage_penalty_played, blockage_detail_played = blockage_penalty(
        evaluation_before,
        evaluation_played,
        board,
        played_move,
        actor,
        phase_ratio,
    )
    blockage_penalty_best, blockage_detail_best = blockage_penalty(
        evaluation_before,
        evaluation_best,
        board,
        best.move,
        actor,
        phase_ratio,
    )
    if blockage_penalty_played >= blockage_trigger_margin:
        structural_event = True
        structural_event_details.setdefault("blockage", blockage_penalty_played)
    elif blockage_penalty_played >= blockage_threshold:
        structural_event_details.setdefault(
            "blockage_soft", round(blockage_penalty_played * SOFT_BLOCK_SCALE, 3)
        )
    if blockage_penalty_best >= blockage_trigger_margin:
        structural_event_best = True
        structural_event_details_best.setdefault("blockage", blockage_penalty_best)
    elif blockage_penalty_best >= blockage_threshold:
        structural_event_details_best.setdefault(
            "blockage_soft", round(blockage_penalty_best * SOFT_BLOCK_SCALE, 3)
        )

    prophylactic_reasons: List[str] = []
    preventive_score = 0.0
    self_safety_bonus = 0.0
    threat_before = threat_after = None
    threat_delta = 0.0
    pattern_reason: Optional[str] = None
    threat_reduced = False
    opp_restrained = False
    self_solidified = False

    control_meta = analysis_meta["control_dynamics"]
    control_meta.setdefault("gates", {})

    if allow_positional:
        if (
            is_quiet(board, played_move)
            and contact_delta_played < TENSION_CONTACT_DELAY
            and not board.gives_check(played_move)
            and delta_eval_float > -0.5
            and delta_self_mobility < 0.2
            and not is_center_pawn_push
        ):
            deferred_initiative = True
            notes["deferred_initiative"] = (
                "quiet move maintained stability while reducing own activity to tighten the position"
            )

        king_safety_gain = change_played_vs_before["king_safety"]
        opp_tactics_change = opp_change_played_vs_before["tactics"]

        if not risk_avoidance:
            drop_cp_condition = drop_cp > -50  # -0.5 pawns
            if (
                delta_self_mobility <= -0.05
                and (king_safety_gain >= 0.05 or opp_tactics_change <= -0.05)
                and drop_cp_condition
            ):
                risk_avoidance = True
                notes["risk_avoidance"] = (
                    f"mobility {delta_self_mobility:+.2f} traded for safety {king_safety_gain:+.2f} "
                    f"and tactics {opp_tactics_change:+.2f}; eval change {drop_cp/100:+.2f}"
                )

        if structure_gain >= 0.25 and tactics_gain <= 0.1:
            structural_integrity = True
            notes["structural_integrity"] = (
                f"structure improved by {structure_gain:+.2f} while tactics change {tactics_gain:+.2f}"
            )

        if is_prophylaxis_candidate(board, played_move):
            self_ks_gain = max(self_vs_best["king_safety"], change_played_vs_before["king_safety"])
            self_structure_gain = max(self_vs_best["structure"], structure_gain)
            self_mobility_change = change_played_vs_before["mobility"]

            opp_mobility_change = opp_vs_best["mobility"]
            opp_tactics_change = opp_vs_best["tactics"]

            threat_before = estimate_opponent_threat(engine_path, board, actor, config=PROPHYLAXIS_CONFIG)
            threat_after = estimate_opponent_threat(engine_path, played_board, actor, config=PROPHYLAXIS_CONFIG)
            threat_delta = round(threat_before - threat_after, 3)
            threat_reduced = threat_delta >= PROPHYLAXIS_CONFIG.threat_drop

            opp_restrained = (
                opp_trend < 0.0
                or opp_mobility_change <= -0.05
                or opp_tactics_change <= -0.1
            )
            self_solidified = (self_structure_gain >= 0.0) or (center_gain >= 0.05)

            pattern_reason = prophylaxis_pattern_reason(
                board,
                played_move,
                opp_trend,
                opp_change_played_vs_before["tactics"],
            )
            pattern_support = pattern_reason is not None
            if pattern_support:
                prophylactic_reasons.append(pattern_reason)
                prophylaxis_pattern_support = True

            if (
                self_structure_gain >= PROPHYLAXIS_CONFIG.structure_min
                and abs(self_mobility_change) <= PROPHYLAXIS_CONFIG.self_mobility_tol
            ):
                prophylactic_reasons.append(
                    f"self consolidation: structure {self_structure_gain:+.2f}, king safety {self_ks_gain:+.2f}, mobility {self_mobility_change:+.2f}"
                )

            preventive_score = round(
                max(0.0, threat_delta) * 0.5
                + max(0.0, -opp_mobility_change) * 0.3
                + max(0.0, -opp_tactics_change) * 0.2
                + max(0.0, -opp_trend) * 0.15,
                3,
            )
            ctx["preventive_score"] = preventive_score
            ctx["threat_delta"] = threat_delta
            safety_raw = (
                max(0.0, self_structure_gain) * 0.4
                + max(0.0, self_ks_gain) * 0.4
                + max(0.0, -self_mobility_change) * 0.2
            )
            self_safety_bonus = round(
                clamp_preventive_score(safety_raw, config=PROPHYLAXIS_CONFIG),
                3,
            )

            adjusted_preventive = preventive_score
            pattern_override_active = False
            if pattern_support and preventive_score >= PROPHYLAXIS_CONFIG.preventive_trigger * 0.75:
                adjusted_preventive = max(preventive_score, PROPHYLAXIS_CONFIG.preventive_trigger)
                pattern_override_active = True
                prophylactic_reasons.append(
                    f"pattern support override (score {preventive_score:+.2f} → {adjusted_preventive:+.2f})"
                )

            if adjusted_preventive >= PROPHYLAXIS_CONFIG.preventive_trigger:
                prophylactic_move = True
                prophylactic_reasons.append(
                    f"preventive score {adjusted_preventive:+.2f} ≥ trigger {PROPHYLAXIS_CONFIG.preventive_trigger:+.2f}"
                )

            if self_safety_bonus > 0:
                prophylactic_reasons.append(
                    f"self safety bonus {self_safety_bonus:+.2f}"
                )

            prophylaxis_score = adjusted_preventive
            telemetry_entry = analysis_meta.setdefault("prophylaxis", {}).setdefault("telemetry", {})
            telemetry_entry["pattern_override"] = pattern_override_active
            if pattern_override_active:
                prophylaxis_pattern_override = True

            if (threat_reduced or opp_restrained) and self_solidified:
                detail_parts = []
                if threat_reduced:
                    detail_parts.append(f"threat ↓{threat_delta:+.2f}")
                if opp_trend <= 0.0:
                    detail_parts.append(f"opp mobility trend {opp_trend:+.2f}")
                if opp_tactics_change <= -0.1:
                    detail_parts.append(f"opp tactics {opp_tactics_change:+.2f}")
                if center_gain >= 0.0:
                    detail_parts.append(f"center {center_gain:+.2f}")
                detail_text = ", ".join(detail_parts) if detail_parts else "preventive control"
                prophylactic_reasons.append(f"preventive context: {detail_text}")

            analysis_meta.setdefault("prophylaxis", {})
            analysis_meta["prophylaxis"].update(
                {
                    "threat_before": threat_before,
                    "threat_after": threat_after,
                    "threat_delta": threat_delta,
                    "pattern": pattern_reason,
                    "components": {
                        "preventive_score": preventive_score,
                        "self_safety_bonus": self_safety_bonus,
                    },
                    "telemetry": {
                        "self_structure_gain": round(self_structure_gain, 3),
                        "self_king_safety_gain": round(self_ks_gain, 3),
                        "self_mobility_change": round(self_mobility_change, 3),
                        "opp_mobility_change": round(opp_mobility_change, 3),
                        "opp_tactics_change": round(opp_tactics_change, 3),
                        "preventive_score": preventive_score,
                        "self_safety_bonus": self_safety_bonus,
                        "opp_trend": round(opp_trend, 3),
                        "self_trend": round(self_trend, 3),
                        "pattern_override": prophylaxis_pattern_override,
                    },
                }
            )
            if prophylactic_reasons:
                notes["prophylactic_move"] = " | ".join(prophylactic_reasons)
                analysis_meta["prophylaxis"]["reasons"] = prophylactic_reasons

            if prophylactic_move:
                if self_mobility_change > 0:
                    notes["prophylaxis_type"] = "active prophylaxis (reposition and restrict)"
                elif preventive_score >= PROPHYLAXIS_CONFIG.score_threshold:
                    notes["prophylaxis_type"] = "preventive prophylaxis (plan suppression)"

        plan_drop_result = None
        if PLAN_DROP_ENABLED and plan_candidate:
            plan_drop_result = detect_prophylaxis_plan_drop(
                engine_path,
                board,
                played_board,
                depth=PLAN_DROP_DEPTH,
                multipv=PLAN_DROP_MULTIPV,
                sample_rate=PLAN_DROP_SAMPLE_RATE,
                variance_cap=PLAN_DROP_VARIANCE_CAP,
                runtime_cap_ms=PLAN_DROP_RUNTIME_CAP_MS,
            )
        if plan_drop_result:
            plan_pass = (
                plan_drop_result.sampled
                and plan_drop_result.stable
                and plan_drop_result.psi >= PLAN_DROP_PSI_MIN
                and plan_drop_result.plan_loss >= PLAN_DROP_PLAN_LOSS_MIN
                and delta_eval_float >= PLAN_DROP_EVAL_CAP
                and "sample_skipped" not in plan_drop_result.reasons
            )
            plan_meta.update(
                {
                    "psi": plan_drop_result.psi,
                    "pei": plan_drop_result.pei,
                    "plan_loss": plan_drop_result.plan_loss,
                    "depth": plan_drop_result.depth,
                    "multipv": plan_drop_result.multipv,
                    "stable": plan_drop_result.stable,
                    "runtime_ms": plan_drop_result.runtime_ms,
                    "sampled": plan_drop_result.sampled,
                    "reasons": plan_drop_result.reasons,
                    "variance_before": plan_drop_result.variance_before,
                    "variance_after": plan_drop_result.variance_after,
                    "passed": plan_pass,
                }
            )
            if plan_pass and not prophylactic_move:
                prophylactic_move = True
            if plan_pass:
                plan_note = (
                    f"plan disruption: psi {plan_drop_result.psi:.2f}, loss {plan_drop_result.plan_loss:.2f}"
                )
                if "prophylactic_move" in notes:
                    notes["prophylactic_move"] = f"{notes['prophylactic_move']} | {plan_note}"
                else:
                    notes["prophylactic_move"] = plan_note
                existing = notes.get("prophylaxis_type")
                if existing:
                    notes["prophylaxis_type"] = f"{existing} | {plan_note}"
                else:
                    notes["prophylaxis_type"] = plan_note
        else:
            plan_meta.setdefault("sampled", False)
            plan_meta.setdefault("passed", None)

        ctx["prophylaxis_plan_drop"] = bool(plan_meta.get("passed"))
        prophylaxis_line_seal = False
        if prophylactic_move and not ctx["prophylaxis_plan_drop"]:
            if moved_piece and moved_piece.piece_type in {chess.ROOK, chess.QUEEN}:
                pressure_drop = ctx.get("opp_line_pressure_drop", 0.0)
                ratio_drop = (
                    (opp_contact_before.get("ratio", 0.0) or 0.0)
                    - (opp_contact_after.get("ratio", 0.0) or 0.0)
                )
                if pressure_drop >= 1.0 or ratio_drop >= 0.05:
                    prophylaxis_line_seal = True
        ctx["prophylaxis_line_seal"] = prophylaxis_line_seal
        if ctx["prophylaxis_plan_drop"]:
            ctx["plan_drop_passed"] = True
        elif ctx["prophylaxis_line_seal"]:
            ctx["opp_line_pressure_drop"] = max(
                ctx.get("opp_line_pressure_drop", 0.0),
                float(control_cfg.get("LINE_MIN", 0)),
            )
            ctx["break_candidates_delta"] = min(ctx.get("break_candidates_delta", 0.0), -1.0)
    else:
        analysis_meta.setdefault("prophylaxis", {})
        plan_meta.setdefault("sampled", False)
        plan_meta.setdefault("passed", None)

    analysis_meta["prophylaxis"].setdefault(
        "components", {"preventive_score": 0.0, "self_safety_bonus": 0.0}
    )
    analysis_meta["prophylaxis"].setdefault("telemetry", {})
    analysis_meta["prophylaxis"]["telemetry"].setdefault("pattern_override", False)

    recent_info = control_meta.get("recent") or {}
    previous_kind = recent_info.get("kind") if isinstance(recent_info, dict) else None
    current_ply_index = analysis_meta.get("ply_index")
    if current_ply_index is None:
        current_ply_index = _current_ply_index(board, actor)
    control_meta["current_ply"] = current_ply_index
    ctx["current_ply"] = current_ply_index
    ctx["cooldown_plies"] = control_cfg.get("COOLDOWN_PLIES", CONTROL_COOLDOWN_PLIES)

    selected_entry, suppressed_subtypes, cooldown_remaining, gate_log, detected_entries = select_cod_subtype(
        ctx,
        control_cfg,
        recent_info,
    )
    control_meta["gates"] = gate_log
    control_meta["candidates"] = detected_entries
    ctx = control_meta.setdefault("context", {})
    candidate_names: Set[str] = set()
    candidate_names.update(entry["name"] for entry in detected_entries)
    candidate_names.update(name for name in suppressed_subtypes if name in COD_SUBTYPES)
    if selected_entry:
        candidate_names.add(selected_entry["name"])
    candidates_map = {name: (name in candidate_names) for name in COD_SUBTYPES}
    ctx["candidates"] = candidates_map
    ctx["suppressed"] = list(suppressed_subtypes)
    ctx["cooldown_remaining"] = cooldown_remaining
    cooldown_hit = bool(
        previous_kind
        and previous_kind in suppressed_subtypes
        and previous_kind != (selected_entry["name"] if selected_entry else None)
        and cooldown_remaining > 0
    )
    ctx["cooldown_hit"] = cooldown_hit
    suppressed_by = suppressed_subtypes[0] if (not selected_entry and suppressed_subtypes) else None
    ctx["suppressed_by"] = suppressed_by

    if selected_entry:
        summary_metrics = dict(selected_entry.get("metrics", {}))
        summary_metrics.setdefault("volatility_drop_cp", ctx.get("volatility_drop_cp"))
        summary_metrics.setdefault("tension_delta", ctx.get("tension_delta"))
        summary_metrics.setdefault("opp_mobility_drop", ctx.get("opp_mobility_drop"))
        summary_metrics.setdefault("king_safety_gain", ctx.get("king_safety_gain"))
        summary_metrics.setdefault("opp_tactics_change_eval", ctx.get("opp_tactics_change_eval"))
        control_over_dynamics = True
        control_over_dynamics_subtype = selected_entry["name"]
        control_meta["subtype"] = control_over_dynamics_subtype
        control_meta["selected"] = {
            "kind": control_over_dynamics_subtype,
            "metrics": summary_metrics,
            "why": selected_entry.get("why"),
        }
        ctx["selected_kind"] = control_over_dynamics_subtype
        ctx["selected_metrics"] = summary_metrics
        suppressed_text = ",".join(suppressed_subtypes) if suppressed_subtypes else "-"
        gates_text = (
            f"evalΔ:{ctx.get('eval_drop_cp', 0)}, "
            f"volΔ:{ctx.get('vol_drop_cp', 0.0):.1f}, "
            f"tensionΔ:{ctx.get('tension_delta', 0.0):+.1f}, "
            f"opMobΔ:{ctx.get('op_mob_drop', 0.0):+.1f}"
        )
        base_note = (
            f"CoD.{control_over_dynamics_subtype}: {selected_entry['why']}; "
            f"gates=[{gates_text}] suppressed={suppressed_text or '-'} "
            f"cooldown={cooldown_remaining}"
        )
        if CONTROL.get("DEBUG_CONTEXT"):
            active_candidates = [name for name, active in candidates_map.items() if active]
            cand_text = ",".join(active_candidates)
            debug_suffix = (
                f" cand=[{cand_text}] suppressed_by={suppressed_by or '-'}"
            )
            notes["control_over_dynamics"] = base_note + debug_suffix
        else:
            notes["control_over_dynamics"] = base_note
        control_meta["recent"] = {
            "kind": control_over_dynamics_subtype,
            "ply": current_ply_index,
        }
        for key in cod_flags:
            cod_flags[key] = False
        if control_over_dynamics_subtype in cod_flags:
            cod_flags[control_over_dynamics_subtype] = True
        mapped_cod = LEGACY_COD_BRIDGE.get(control_over_dynamics_subtype)
        if mapped_cod and mapped_cod in cod_flags:
            cod_flags[mapped_cod] = True
    else:
        ctx["selected_kind"] = None
        ctx["selected_metrics"] = {}
        control_meta["selected"] = None
        control_meta["subtype"] = None
        if CONTROL.get("DEBUG_CONTEXT"):
            active_candidates = [name for name, active in candidates_map.items() if active]
            cand_text = ",".join(active_candidates)
            debug_note = (
                f"CoD.none cand=[{cand_text}] suppressed_by={suppressed_by or '-'} "
                f"cooldown={cooldown_remaining}"
            )
            notes["control_over_dynamics"] = debug_note
        control_meta["recent"] = {"kind": None, "ply": current_ply_index}

    control_over_dynamics = any(cod_flags.values())
    ctx["control_over_dynamics"] = control_over_dynamics
    ctx["control_subtype"] = control_over_dynamics_subtype
    ctx["cod_flags"] = dict(cod_flags)

    prophylaxis_quality = None
    has_prophylaxis_signal = (
        prophylactic_move
        or prophylaxis_pattern_support
        or plan_candidate
        or preventive_score > 0
    )
    if has_prophylaxis_signal:
        telemetry = analysis_meta["prophylaxis"].setdefault("telemetry", {})
        pattern_override = bool(telemetry.get("pattern_override"))
        soft_weight = _soft_gate_weight(effective_delta)
        effective_preventive = adjusted_preventive if adjusted_preventive else preventive_score
        if pattern_override and effective_preventive < PROPHYLAXIS_CONFIG.preventive_trigger:
            effective_preventive = PROPHYLAXIS_CONFIG.preventive_trigger
        prophylaxis_quality, quality_score = classify_prophylaxis_quality(
            has_prophylaxis_signal,
            effective_preventive,
            effective_delta,
            tactical_weight,
            soft_weight,
            config=PROPHYLAXIS_CONFIG,
        )
        if plan_candidate and plan_meta.get("passed") is False:
            prophylaxis_quality = "prophylactic_failed"
            quality_score = 0.0
        elif plan_candidate and plan_meta.get("passed") and prophylaxis_quality == "prophylactic_soft":
            prophylaxis_quality = "prophylactic_strong"
            quality_score = max(quality_score, 0.8)
        analysis_meta["prophylaxis"]["quality"] = prophylaxis_quality
        analysis_meta["prophylaxis"]["quality_score"] = quality_score
        analysis_meta["prophylaxis"]["components"].update(
            {
                "preventive_score": preventive_score,
                "effective_preventive": effective_preventive,
                "self_safety_bonus": self_safety_bonus,
                "soft_weight": round(soft_weight, 3),
                "effective_delta": round(effective_delta, 3),
                "pattern_override": pattern_override,
            }
        )
    prophylaxis_quality = analysis_meta["prophylaxis"].get("quality")
    quality_score = analysis_meta["prophylaxis"].get("quality_score")
    if prophylaxis_quality and quality_score is not None:
        notes.setdefault(
            "prophylaxis_quality",
            f"{prophylaxis_quality} (score {quality_score:+.2f})",
        )

    # ----- Directional pressure (e.g., c-file) -----
    file_pressure_info: Dict[str, Any] = {}
    file_pressure_score = 0.0
    if board.piece_at(played_move.from_square):
        file_pressure_score, file_pressure_info = file_pressure(
            board,
            played_board,
            actor,
            chess.FILE_NAMES.index("c"),
            chess.C7 if actor == chess.WHITE else chess.C2,
        )
        analysis_meta.setdefault("directional_pressure", {})
        file_pressure_info["score"] = round(file_pressure_score, 3)
        file_pressure_info["triggered"] = file_pressure_score >= FILE_PRESSURE_THRESHOLD
        analysis_meta["directional_pressure"]["c"] = file_pressure_info

        if file_pressure_score >= FILE_PRESSURE_THRESHOLD:
            file_pressure_c_flag = True
            notes.setdefault(
                "file_pressure:c",
                f"pressure score {file_pressure_score:.2f} (AD={file_pressure_info.get('ad')}, xray={file_pressure_info.get('xray')})",
            )

    # ----- Risk avoidance detection -----
    eval_loss = abs(delta_eval_float)
    if detect_risk_avoidance(
        change_played_vs_before["king_safety"],
        eval_loss,
        opp_change_played_vs_before["tactics"],
        contact_delta_played,
    ):
        if not risk_avoidance:
            notes.setdefault(
                "risk_avoidance",
                f"risk avoidance: king safety {change_played_vs_before['king_safety']:+.2f}, eval loss {eval_loss:+.2f}"
            )
        risk_avoidance = True

    behavior_scores = compute_behavior_scores(
        change_played_vs_before["mobility"],
        change_played_vs_before["center_control"],
        effective_delta,
        file_pressure_info.get("delta", 0.0),
        max(0.0, -change_played_vs_before["structure"]),
        change_played_vs_before["king_safety"],
        opp_change_played_vs_before["mobility"],
    )
    analysis_meta.setdefault("behavior_scores", {}).update(behavior_scores)

    eval_bundles = EvalBundles(
        metrics_before=metrics_before,
        metrics_played=metrics_played,
        metrics_best=metrics_best,
        opp_before=opp_metrics_before,
        opp_played=opp_metrics_played,
        opp_best=opp_metrics_best,
        component_deltas=component_deltas,
        opp_component_deltas=opp_component_deltas,
    )
    followups_bundle = Followups(
        base_self_before=base_self_before,
        base_opp_before=base_opp_before,
        base_self_played=base_self_played,
        base_opp_played=base_opp_played,
        base_self_best=base_self_best,
        base_opp_best=base_opp_best,
        self_played=follow_self_deltas,
        opp_played=follow_opp_deltas,
        self_best=follow_self_deltas_best,
        opp_best=follow_opp_deltas_best,
    )
    position_ctx = PositionContext(
        board=board,
        actor=actor,
        played=played_move,
        best=best.move,
        phase_ratio=phase_ratio,
        eval_before_cp=eval_before_cp,
        eval_played_cp=eval_played_cp,
        eval_best_cp=eval_best_cp,
        metrics_before=metrics_before,
        metrics_played=metrics_played,
        metrics_best=metrics_best,
        opp_before=opp_metrics_before,
        opp_played=opp_metrics_played,
        opp_best=opp_metrics_best,
        change_played_vs_before=change_played_vs_before,
        opp_change_played_vs_before=opp_change_played_vs_before,
        tactical_weight=tactical_weight,
        delta_eval_cp=delta_eval_cp,
        delta_eval_float=delta_eval_float,
        drop_cp=drop_cp,
        effective_delta=effective_delta,
        coverage_before=coverage_before,
        coverage_after=coverage_after,
        coverage_best=coverage_best,
        contact_ratio_before=contact_ratio_before,
        contact_ratio_played=contact_ratio_played,
        contact_ratio_best=contact_ratio_best,
        followups=followups_bundle,
        trends={
            "self_played": self_trend,
            "opp_played": opp_trend,
            "self_best": self_trend_best,
            "opp_best": opp_trend_best,
        },
        windows={
            "self_window_mean": follow_window_mean,
            "self_window_var": follow_window_var,
        },
        eval_bundles=eval_bundles,
        analysis_meta=analysis_meta,
        extras={
            "file_pressure": file_pressure_info,
        },
    )
    maneuver_flags, maneuver_notes, maneuver_extras = detect_maneuver(position_ctx, THRESHOLDS_VIEW)
    for key, value in maneuver_notes.items():
        notes.setdefault(key, value)
    if maneuver_extras.get("behavior_scores"):
        analysis_meta.setdefault("behavior_scores", {}).update(maneuver_extras["behavior_scores"])
    if "maneuver_details" in maneuver_extras:
        analysis_meta.setdefault("maneuver_details", {}).update(maneuver_extras["maneuver_details"])
    maneuver_precision_score = maneuver_extras.get("maneuver_precision_score", maneuver_precision_score)
    maneuver_timing_score = maneuver_extras.get("maneuver_timing_score", maneuver_timing_score)
    constructive_maneuver = constructive_maneuver or maneuver_flags.get("constructive_maneuver", False)
    neutral_maneuver = neutral_maneuver or maneuver_flags.get("neutral_maneuver", False)
    misplaced_maneuver = misplaced_maneuver or maneuver_flags.get("misplaced_maneuver", False)
    maneuver_opening = maneuver_opening or maneuver_flags.get("maneuver_opening", False)

    # ----- Premature attack -----
    if is_attacking_pawn_push(board, played_move, actor):
        structure_drop = max(0.0, -structure_gain)
        king_attack_potential = max(file_pressure_score, max(0.0, contact_delta_played))
        piece_inflow = max(0.0, behavior_scores.get("aggression", 0.0))
        self_king_risk = max(0.0, -change_played_vs_before["king_safety"])
        opp_reinforce = max(0.0, opp_change_played_vs_before["mobility"])
        tactic_against = max(0.0, opp_change_played_vs_before["tactics"])
        comp = compute_premature_compensation(
            structure_drop,
            change_played_vs_before["mobility"],
            center_gain,
            king_attack_potential,
            piece_inflow,
            self_king_risk,
            opp_reinforce,
            tactic_against,
        )
        analysis_meta.setdefault("premature_attack", {})
        analysis_meta["premature_attack"].update(
            {
                "score": round(comp, 3),
                "structure_drop": round(structure_drop, 3),
                "mobility_gain": round(change_played_vs_before["mobility"], 3),
                "center_gain": round(center_gain, 3),
            }
        )
        low_comp = comp <= PREMATURE_ATTACK_THRESHOLD
        hard_flag = (delta_eval_float <= -0.6 and structure_drop >= 0.2) or comp <= PREMATURE_ATTACK_HARD
        if low_comp or hard_flag:
            premature_attack = True
            notes.setdefault("premature_attack", f"compensation {comp:+.2f}")
            if comp <= PREMATURE_ATTACK_HARD:
                initiative_attempt = False

    if delta_self_mobility > 0.3 and drop_cp < 50 and not prophylactic_move:
        initiative_attempt = True
        notes["initiative_attempt"] = (
            f"expansion attempt: mobility {delta_self_mobility:+.2f}, eval {delta_eval_float:+.2f}"
        )

    if tactics_gain >= 0.3:
        tactical_sensitivity = True
        notes["tactical_sensitivity"] = (
            f"tactics component increased by {tactics_gain:+.2f}"
        )

    if drop_cp >= INITIATIVE_BOOST and change_played_vs_before["mobility"] > 0:
        initiative_exploitation = True
        notes["initiative_exploitation"] = (
            f"eval improved by {delta_eval_played_vs_before/100:.2f} with mobility gain "
            f"{change_played_vs_before['mobility']:+.2f}"
        )

    structural_reasons: List[Dict[str, Any]] = []

    if allow_structural:
        structural_detail_parts = []
        if delta_isolated > 0:
            structural_detail_parts.append(f"isolated +{delta_isolated}")
            structural_reasons.append({"type": "isolated_increase", "value": delta_isolated})
        if delta_doubled > 0:
            structural_detail_parts.append(f"doubled +{delta_doubled}")
            structural_reasons.append({"type": "doubled_increase", "value": delta_doubled})
        if delta_backward > 0:
            structural_detail_parts.append(f"backward +{delta_backward}")
            for sq_name in backward_added:
                piece = played_board.piece_at(chess.parse_square(sq_name))
                file_label = chr(ord('a') + chess.square_file(chess.parse_square(sq_name)))
                structural_reasons.append(
                    {
                        "type": "backward_increase",
                        "square": sq_name,
                        "piece": chess.piece_name(piece.piece_type) if piece else None,
                        "file": file_label,
                    }
                )
        if delta_islands > 0:
            structural_detail_parts.append(f"islands +{delta_islands}")
            structural_reasons.append({"type": "islands_increase", "value": delta_islands})
        if delta_chains < 0:
            structural_detail_parts.append(f"chains {delta_chains:+}")
            structural_reasons.append({"type": "chains_drop", "value": delta_chains})
        if delta_shield < 0:
            structural_detail_parts.append(f"shield {delta_shield:+}")
            structural_reasons.append({"type": "shield_drop", "value": delta_shield})
        if structure_score_gain <= structure_drop_threshold:
            structural_detail_parts.append(f"structure_score {structure_score_gain:+.2f}")
            structural_reasons.append({"type": "structure_score_drop", "value": round(structure_score_gain, 3)})
        if blockage_penalty_played >= blockage_trigger_margin:
            structural_detail_parts.append(f"blockage {blockage_penalty_played:+.2f}")
            structural_reasons.append({"type": "blockage_hard", "value": round(blockage_penalty_played, 3)})
        elif blockage_penalty_played >= blockage_threshold:
            structural_detail_parts.append(
                f"blockage_soft {blockage_penalty_played * SOFT_BLOCK_SCALE:+.2f}"
            )
            structural_reasons.append(
                {
                    "type": "blockage_soft",
                    "value": round(blockage_penalty_played * SOFT_BLOCK_SCALE, 3),
                }
            )
        for square_name, delta, weight in blockage_detail_played:
            piece = played_board.piece_at(chess.parse_square(square_name))
            if not piece:
                continue
            structural_reasons.append(
                {
                    "type": "blockage_piece",
                    "square": square_name,
                    "piece": chess.piece_name(piece.piece_type),
                    "file": f"{chr(ord('a') + chess.square_file(chess.parse_square(square_name)))}-file",
                    "delta": round(delta, 3),
                }
            )

        if structural_event and not structural_event_best:
            mobility_gain_now = change_played_vs_before["mobility"]
            opp_mobility_change_now = opp_change_played_vs_before["mobility"]
            mobility_gain_future = follow_self_deltas[-1]["mobility"] if follow_self_deltas else 0.0
            opp_mobility_change_future = follow_opp_deltas[-1]["mobility"] if follow_opp_deltas else 0.0

            mobility_trend_threshold_self = 0.1 + 0.15 * (1 - phase_ratio)
            mobility_trend_threshold_opp = 0.1 + 0.12 * phase_ratio

            self_signal = max(mobility_gain_now, mobility_gain_future, self_trend)
            opp_signal = min(opp_mobility_change_now, opp_mobility_change_future, opp_trend)
            detail_text = ", ".join(structural_detail_parts) if structural_detail_parts else "structure compromised"

            if (
                self_signal >= mobility_trend_threshold_self
                or opp_signal <= -mobility_trend_threshold_opp
                or self_trend >= mobility_trend_threshold_self * 0.75
                or opp_trend <= -mobility_trend_threshold_opp * 0.75
                or tactics_gain >= 0.2
                or center_gain >= 0.2
            ):
                structural_compromise_dynamic = True
                notes["structural_compromise_dynamic"] = (
                    f"{detail_text}; dynamic potential ↑ (self mobility now {mobility_gain_now:+.2f}, future {mobility_gain_future:+.2f}; "
                    f"opponent mobility now {opp_mobility_change_now:+.2f}, future {opp_mobility_change_future:+.2f}; "
                    f"tactics {tactics_gain:+.2f}, center {center_gain:+.2f}; trend self {self_trend:+.2f}, opp {opp_trend:+.2f})"
                )
            else:
                static_condition = (
                    mobility_gain_now <= -0.03
                    and opp_mobility_change_now >= 0.03
                ) or (
                    self_trend <= 0.0 and opp_trend >= 0.03
                )
                structural_compromise_static = True
                reason = (
                    "opponent mobility increases while own mobility falls"
                    if static_condition
                    else "structure weakened without dynamic compensation"
                )
                notes["structural_compromise_static"] = (
                    f"{detail_text}; {reason} (self mobility now {mobility_gain_now:+.2f}, future {mobility_gain_future:+.2f}; "
                    f"opponent mobility now {opp_mobility_change_now:+.2f}, future {opp_mobility_change_future:+.2f}; "
                    f"tactics {tactics_gain:+.2f}, center {center_gain:+.2f}; trend self {self_trend:+.2f}, opp {opp_trend:+.2f})"
                )
        elif structural_event and structural_event_best:
            detail_text = ", ".join(structural_detail_parts) if structural_detail_parts else "structure compromised"
            notes.setdefault(
                "structural_compromise_forced",
                f"{detail_text}; best move required similar structure concession"
            )

        blockage_pieces = [
            reason for reason in structural_reasons if reason.get("type") == "blockage_piece"
        ]
        if blockage_pieces:
            blockage_text = ", ".join(
                f"{entry.get('piece')} {entry.get('square')} on {entry.get('file')}"
                for entry in blockage_pieces
                if entry.get("piece") and entry.get("square")
            )
            if blockage_text:
                for key in (
                    "structural_compromise_dynamic",
                    "structural_compromise_static",
                    "structural_compromise_forced",
                ):
                    if key in notes:
                        notes[key] = f"{notes[key]}; blocked {blockage_text}"

        sacrifice_flags, sacrifice_context = classify_sacrifice(
            board,
            played_board,
            played_move,
            eval_before,
            eval_played,
            change_played_vs_before,
            opp_metrics_before,
            opp_metrics_played,
            tactical_weight,
            behavior_scores.get("aggression", 0.0),
        )

        if sacrifice_flags["tactical_sacrifice"]:
            tactical_sacrifice = True
            notes.setdefault(
                "tactical_sacrifice",
                (
                    f"material loss {sacrifice_context['material_loss']:+.2f}, eval Δ {sacrifice_context['eval_loss']:+.2f}, "
                    f"king safety Δ {sacrifice_context['king_drop']:+.2f}"
                ),
            )
        if sacrifice_flags["positional_sacrifice"]:
            positional_sacrifice = True
            notes.setdefault(
                "positional_sacrifice",
                (
                    f"material loss {sacrifice_context['material_loss']:+.2f}, eval Δ {sacrifice_context['eval_loss']:+.2f}, "
                    f"king safety Δ {sacrifice_context['king_drop']:+.2f}"
                ),
            )
        if sacrifice_flags["inaccurate_tactical_sacrifice"]:
            inaccurate_tactical_sacrifice = True
        if sacrifice_flags["speculative_sacrifice"]:
            speculative_sacrifice = True
        if sacrifice_flags["desperate_sacrifice"]:
            desperate_sacrifice = True
        if sacrifice_flags["tactical_combination_sacrifice"]:
            tactical_combination_sacrifice = True
        if sacrifice_flags["tactical_initiative_sacrifice"]:
            tactical_initiative_sacrifice = True
        if sacrifice_flags["positional_structure_sacrifice"]:
            positional_structure_sacrifice = True
        if sacrifice_flags["positional_space_sacrifice"]:
            positional_space_sacrifice = True

        top_gap_cp = analysis_meta["score_gap_cp"]
        played_is_best = played_move == best.move

        if mode == "tactical" and top_gap_cp >= TACTICAL_GAP_FIRST_CHOICE and played_is_best:
            first_choice = True
            notes["first_choice"] = (
                f"top gap {top_gap_cp/100:.2f}; player found only winning move"
            )

        if top_gap_cp >= TACTICAL_GAP_FIRST_CHOICE and not played_is_best and delta_eval_cp >= TACTICAL_MISS_LOSS:
            missed_tactic = True
            notes["missed_tactic"] = (
                f"missed winning move; loss {delta_eval_cp/100:.2f} after gap {top_gap_cp/100:.2f}"
            )

        if (
            eval_before_cp >= TACTICAL_DOMINANCE_THRESHOLD
            and eval_played_cp >= TACTICAL_DOMINANCE_THRESHOLD
            and abs(delta_eval_played_vs_before) <= CONTROL_EVAL_DROP
        ):
            conversion_precision = True
            notes["conversion_precision"] = "maintained winning evaluation during conversion"

        if delta_eval_played_vs_before <= -250 and change_played_vs_before["mobility"] <= -0.8:
            panic_move = True
            notes["panic_move"] = (
                f"eval dropped {delta_eval_played_vs_before/100:.2f} with mobility {change_played_vs_before['mobility']:+.2f}"
            )

        if eval_before_cp <= -300 and eval_played_cp >= -100:
            tactical_recovery = True
            notes["tactical_recovery"] = "evaluation recovered from near loss"

    if allow_positional or allow_structural:
        phase_ratio_current = analysis_meta.get("phase_ratio", phase_ratio)
        followup_tail_self = follow_self_deltas[-1]["mobility"] if follow_self_deltas else 0.0

        eval_band = TENSION_EVAL_MIN <= delta_eval_float <= TENSION_EVAL_MAX
        self_mag = abs(delta_self_mobility)
        opp_mag = abs(delta_opp_mobility)
        mobility_cross = delta_self_mobility * delta_opp_mobility
        symmetry_gap = abs(self_mag - opp_mag)

        effective_threshold = TENSION_MOBILITY_THRESHOLD * (0.85 + 0.25 * phase_ratio_current)
        near_threshold = max(TENSION_MOBILITY_NEAR, effective_threshold * 0.75)
        symmetry_ok = symmetry_gap <= TENSION_SYMMETRY_TOL

        contact_jump = contact_delta_played
        contact_trigger = contact_jump >= TENSION_CONTACT_JUMP
        contact_direct = contact_jump >= TENSION_CONTACT_DIRECT
        contact_descriptor = f"contact {contact_jump:+.2f}"

        sustain_self_mean, sustain_self_var = _window_stats(follow_self_deltas)
        sustain_opp_mean, sustain_opp_var = _window_stats(follow_opp_deltas)
        sustained_window = (
            sustain_self_mean >= TENSION_SUSTAIN_MIN
            and sustain_opp_mean >= TENSION_SUSTAIN_MIN
            and sustain_self_var <= TENSION_SUSTAIN_VAR_CAP
            and sustain_opp_var <= TENSION_SUSTAIN_VAR_CAP
        )
        window_ok = sustained_window or contact_direct

        mobility_core = (
            self_mag >= effective_threshold
            and opp_mag >= effective_threshold
            and mobility_cross < 0
            and symmetry_ok
        )
        mobility_struct = (
            self_mag >= near_threshold
            and opp_mag >= near_threshold
            and mobility_cross < 0
            and (structural_shift_signal or contact_trigger)
        )

        sustained = (
            delta_eval_float > -0.6
            or self_trend >= 0
            or followup_tail_self >= 0
        )

        analysis_meta["tension_support"].update(
            {
                "effective_threshold": round(effective_threshold, 3),
                "mobility_self": round(delta_self_mobility, 3),
                "mobility_opp": round(delta_opp_mobility, 3),
                "symmetry_gap": round(symmetry_gap, 3),
                "trend_self": round(self_trend, 3),
                "trend_opp": round(opp_trend, 3),
                "sustain_self_mean": round(sustain_self_mean, 3),
                "sustain_self_var": round(sustain_self_var, 3),
                "sustain_opp_mean": round(sustain_opp_mean, 3),
                "sustain_opp_var": round(sustain_opp_var, 3),
                "sustained": sustained_window,
            }
        )

        trigger_sources: List[str] = []
        triggered = False
        contact_eval_ok = delta_eval_float <= -0.2 and mobility_cross < 0

        if eval_band and phase_ratio_current > 0.5 and window_ok and (mobility_core or mobility_struct or (contact_trigger and contact_eval_ok)):
            if delta_eval_float <= TENSION_EVAL_MIN and structural_compromise_dynamic:
                pass
            elif delta_eval_float <= -0.6 and not sustained:
                pass
            else:
                triggered = True
                if contact_trigger:
                    base_label = "contact_direct" if contact_direct else "contact_comp"
                    trigger_sources.append(base_label)
                if mobility_core:
                    trigger_sources.append("symmetry_core")
                if mobility_struct and not mobility_core:
                    trigger_sources.append("structural_support")

        if not triggered and eval_band and phase_ratio_current > 0.5 and sustained_window:
            delayed_contact = contact_jump >= TENSION_CONTACT_DELAY
            delayed_mag = (
                self_mag >= TENSION_MOBILITY_DELAY
                and opp_mag >= TENSION_MOBILITY_DELAY
                and mobility_cross < 0
            )
            delayed_trend = (
                self_trend <= TENSION_TREND_SELF
                and opp_trend >= TENSION_TREND_OPP
            )
            delayed_eval = delta_eval_float <= -0.2 or contact_trigger
            if delayed_contact and delayed_mag and delayed_trend and delayed_eval:
                triggered = True
                trigger_sources.append("delayed_trend")
                if contact_trigger:
                    base_label = "contact_direct" if contact_direct else "contact_comp"
                    trigger_sources.append(base_label)

        unique_sources: List[str] = []
        for src in trigger_sources:
            if src not in unique_sources:
                unique_sources.append(src)
        ordered_sources = sorted(unique_sources, key=lambda name: TENSION_TRIGGER_PRIORITY.get(name, 999))

        if triggered:
            tension_creation = True
            note_parts = [
                f"tension creation: eval {delta_eval_float:+.2f}",
                f"mobility self {delta_self_mobility:+.2f}",
                f"opp {delta_opp_mobility:+.2f}",
            ]
            if contact_trigger:
                note_parts.append(contact_descriptor)
            if structural_shift_signal:
                note_parts.append("structural shift detected")
            trigger_text = " + ".join(ordered_sources) if ordered_sources else "core"
            note_parts.append(f"triggered via {trigger_text}")
            if self_trend > 0:
                note_parts.append(f"follow-up self trend {self_trend:+.2f}")
            elif followup_tail_self > 0:
                note_parts.append(f"next-step mobility {followup_tail_self:+.2f}")
            notes["tension_creation"] = "; ".join(note_parts)
        analysis_meta["tension_support"]["trigger_sources"] = ordered_sources

        neutral_band_active = abs(delta_eval_float) <= NEUTRAL_TENSION_BAND
        analysis_meta["tension_support"]["neutral_band"] = {
            "band_cp": NEUTRAL_TENSION_BAND,
            "delta_eval": round(delta_eval_float, 3),
            "active": neutral_band_active,
        }
        if neutral_band_active and not (tension_creation or contact_trigger or structural_shift_signal):
            neutral_tension_creation = True
            notes.setdefault(
                "neutral_tension_creation",
                f"|Δeval| ≤ {NEUTRAL_TENSION_BAND:.2f}; sources=none",
            )

    if risk_avoidance and not file_pressure_c_flag:
        if "tension_creation" in notes:
            notes.pop("tension_creation", None)
        tension_creation = False
        analysis_meta["tension_support"]["trigger_sources"] = []

    if (
        mover_piece
        and mover_piece.piece_type == chess.PAWN
        and contact_delta_played >= TENSION_CONTACT_DELAY
        and not tension_creation
        and not initiative_attempt
    ):
        notes.setdefault(
            "break_eval_flag",
            "pawn break did not trigger initiative/tension tags; review compensation",
        )

    notes.setdefault(
        "gating_weight",
        f"tactical_weight={tactical_weight:.2f} (mode={mode})"
    )

    analysis_meta.setdefault("structural_details", {})
    analysis_meta["structural_details"].update(
        {
            "before": structural_counts_before,
            "played_delta": structural_event_details,
            "best_delta": structural_event_details_best,
            "blockage_played": {
                "penalty": blockage_penalty_played,
                "details": blockage_detail_played,
                "threshold": round(blockage_threshold, 3),
                "trigger_margin": round(blockage_trigger_margin, 3),
                "soft_scale": SOFT_BLOCK_SCALE,
            },
            "blockage_best": {
                "penalty": blockage_penalty_best,
                "details": blockage_detail_best,
                "threshold": round(blockage_threshold, 3),
                "trigger_margin": round(blockage_trigger_margin, 3),
                "soft_scale": SOFT_BLOCK_SCALE,
            },
        }
    )
    analysis_meta["structural_details"]["reasons"] = structural_reasons
    analysis_meta.setdefault("structural_reasons", structural_reasons)
    analysis_meta.setdefault("followup", {})
    analysis_meta["followup"].update(
        {
            "steps": followup_steps,
            "self_base": base_self_played,
            "opp_base": base_opp_played,
            "self_seq": follow_self_deltas,
            "opp_seq": follow_opp_deltas,
            "self_seq_best": follow_self_deltas_best,
            "opp_seq_best": follow_opp_deltas_best,
            "self_trend": round(self_trend, 3),
            "opp_trend": round(opp_trend, 3),
            "self_trend_best": round(self_trend_best, 3),
            "opp_trend_best": round(opp_trend_best, 3),
        }
    )
    analysis_meta.setdefault("tension_support", {})
    analysis_meta["tension_support"].setdefault(
        "thresholds",
        {
            "tension_mobility_min": TENSION_MOBILITY_THRESHOLD,
            "tension_mobility_near": TENSION_MOBILITY_NEAR,
            "contact_ratio_min": TENSION_CONTACT_JUMP,
            "contact_ratio_delay": TENSION_CONTACT_DELAY,
            "tension_mobility_delay": TENSION_MOBILITY_DELAY,
            "tension_trend_self": TENSION_TREND_SELF,
            "tension_trend_opp": TENSION_TREND_OPP,
            "neutral_eval_band": NEUTRAL_TENSION_BAND,
        },
    )
    analysis_meta["ruleset_version"] = "rulestack_2025-11-03"
    telemetry = analysis_meta.setdefault("telemetry", {})
    telemetry["tension"] = {
        "triggered": tension_creation,
        "sources": analysis_meta["tension_support"].get("trigger_sources"),
        "sustained": analysis_meta["tension_support"].get("sustained"),
        "sustain_means": {
            "self": analysis_meta["tension_support"].get("sustain_self_mean"),
            "opp": analysis_meta["tension_support"].get("sustain_opp_mean"),
        },
        "neutral": {
            "active": neutral_tension_creation,
            "band_cp": NEUTRAL_TENSION_BAND,
            "band_state": analysis_meta["tension_support"].get("neutral_band"),
        },
    }
    telemetry["structural"] = {
        "event": structural_event,
        "reasons": structural_reasons,
        "blockage_penalty": blockage_penalty_played,
    }
    telemetry["directional_pressure"] = analysis_meta.get("directional_pressure")
    if "prophylaxis" in analysis_meta:
        telemetry["prophylaxis"] = analysis_meta["prophylaxis"].get("telemetry")
        telemetry["prophylaxis_components"] = analysis_meta["prophylaxis"].get("components")
    if "prophylaxis_plan" in analysis_meta:
        telemetry["plan_drop"] = analysis_meta["prophylaxis_plan"]
    telemetry["context"] = analysis_meta.get("context")
    telemetry["intent"] = analysis_meta.get("intent_hint")

    intent_label_final = analysis_meta.get("intent_hint", {}).get("label")
    intent_flags = {
        "expansion": intent_label_final == "expansion",
        "restriction": intent_label_final == "restriction",
        "passive": intent_label_final == "passive",
        "neutral": intent_label_final == "neutral",
    }
    analysis_meta["intent_flags"] = intent_flags

    context_label = None
    if tau > 1.05:
        context_label = "winning_position_handling"
    elif tau < 0.95:
        context_label = "losing_position_handling"
    analysis_meta["context"]["label"] = context_label

    tag_flags = {
        "control_over_dynamics": control_over_dynamics,
        "cod_simplify": cod_flags["simplify"],
        "cod_plan_kill": cod_flags["plan_kill"],
        "cod_freeze_bind": cod_flags["freeze_bind"],
        "cod_blockade_passed": cod_flags["blockade_passed"],
        "cod_file_seal": cod_flags["file_seal"],
        "cod_king_safety_shell": cod_flags["king_safety_shell"],
        "cod_space_clamp": cod_flags["space_clamp"],
        "cod_regroup_consolidate": cod_flags["regroup_consolidate"],
        "cod_slowdown": cod_flags["slowdown"],
        "deferred_initiative": deferred_initiative,
        "risk_avoidance": risk_avoidance,
        "structural_integrity": structural_integrity,
        "structural_compromise_dynamic": structural_compromise_dynamic,
        "structural_compromise_static": structural_compromise_static,
        "tactical_sensitivity": tactical_sensitivity,
        "prophylactic_move": prophylactic_move,
        "file_pressure_c": file_pressure_c_flag,
        "premature_attack": premature_attack,
        "neutral_tension_creation": neutral_tension_creation,
        "constructive_maneuver": constructive_maneuver,
        "neutral_maneuver": neutral_maneuver,
        "misplaced_maneuver": misplaced_maneuver,
        "maneuver_opening": maneuver_opening,
        "tactical_sacrifice": tactical_sacrifice,
        "positional_sacrifice": positional_sacrifice,
        "inaccurate_tactical_sacrifice": inaccurate_tactical_sacrifice,
        "speculative_sacrifice": speculative_sacrifice,
        "desperate_sacrifice": desperate_sacrifice,
        "tactical_combination_sacrifice": tactical_combination_sacrifice,
        "tactical_initiative_sacrifice": tactical_initiative_sacrifice,
        "positional_structure_sacrifice": positional_structure_sacrifice,
        "positional_space_sacrifice": positional_space_sacrifice,
        "initiative_exploitation": initiative_exploitation,
        "initiative_attempt": initiative_attempt,
        "tension_creation": tension_creation,
        "first_choice": first_choice,
        "missed_tactic": missed_tactic,
        "conversion_precision": conversion_precision,
        "panic_move": panic_move,
        "tactical_recovery": tactical_recovery,
    }
    analysis_meta.setdefault("tag_flags", tag_flags)

    raw_tags = assemble_tags(tag_flags, TAG_ALIAS_MAP)
    analysis_meta["tags_initial"] = raw_tags.copy()

    if prophylaxis_quality and "prophylactic_move" in raw_tags:
        raw_tags = [tag for tag in raw_tags if tag != "prophylactic_move"]
        raw_tags.append(prophylaxis_quality)

    analysis_meta["tags_secondary"] = raw_tags.copy()
    if context_label:
        analysis_meta["tags_secondary"].append(context_label)

    gated_tags, gating_reason = apply_tactical_gating(
        raw_tags,
        effective_delta,
        material_delta_self,
        blockage_penalty_played,
        plan_meta.get("passed"),
    )
    if gated_tags is None:
        gated_tags = raw_tags

    gated_tags = list(dict.fromkeys(gated_tags))
    if neutral_tension_creation and "intent_neutral" in gated_tags:
        gated_tags = [tag for tag in gated_tags if tag != "intent_neutral"]
        notes.setdefault(
            "neutral_tension_override",
            "intent_neutral suppressed due to neutral tension classification",
        )

    analysis_meta["gating"] = {
        "reason": gating_reason,
        "material_delta": material_delta_self,
        "eval_delta": delta_eval_float,
        "tags_primary": gated_tags,
    }
    telemetry["gating"] = analysis_meta["gating"]
    if gating_reason:
        notes.setdefault("gating", gating_reason)

    for key in tag_flags:
        alias = TAG_ALIAS_MAP.get(key)
        tag_flags[key] = (key in gated_tags) or (alias in gated_tags if alias else False)

    trigger_order = sorted(
        gated_tags,
        key=lambda name: TAG_PRIORITY.get(name, 999),
    )
    analysis_meta["trigger_order"] = trigger_order

    _maybe_attach_control_context_snapshot(ctx, notes)

    return TagResult(
        played_move=played_move_uci,
        played_kind=played_kind,
        best_move=best.move.uci(),
        best_kind=best.kind,
        eval_before=eval_before,
        eval_played=eval_played,
        eval_best=eval_best,
        delta_eval=delta_eval,
        control_over_dynamics=control_over_dynamics,
        control_over_dynamics_subtype=control_over_dynamics_subtype,
        cod_simplify=cod_flags["simplify"],
        cod_plan_kill=cod_flags["plan_kill"],
        cod_freeze_bind=cod_flags["freeze_bind"],
        cod_blockade_passed=cod_flags["blockade_passed"],
        cod_file_seal=cod_flags["file_seal"],
        cod_king_safety_shell=cod_flags["king_safety_shell"],
        cod_space_clamp=cod_flags["space_clamp"],
        cod_regroup_consolidate=cod_flags["regroup_consolidate"],
        cod_slowdown=cod_flags["slowdown"],
        control_schema_version=2,
        deferred_initiative=deferred_initiative,
        risk_avoidance=risk_avoidance,
        structural_integrity=structural_integrity,
        structural_compromise_dynamic=structural_compromise_dynamic,
        structural_compromise_static=structural_compromise_static,
        tactical_sensitivity=tactical_sensitivity,
        prophylactic_move=prophylactic_move,
        prophylaxis_score=prophylaxis_score,
        initiative_exploitation=initiative_exploitation,
        initiative_attempt=initiative_attempt,
        tension_creation=tension_creation,
        neutral_tension_creation=neutral_tension_creation,
        premature_attack=premature_attack,
        constructive_maneuver=constructive_maneuver,
        neutral_maneuver=neutral_maneuver,
        misplaced_maneuver=misplaced_maneuver,
        maneuver_opening=maneuver_opening,
        tactical_sacrifice=tactical_sacrifice,
        positional_sacrifice=positional_sacrifice,
        inaccurate_tactical_sacrifice=inaccurate_tactical_sacrifice,
        speculative_sacrifice=speculative_sacrifice,
        desperate_sacrifice=desperate_sacrifice,
        tactical_combination_sacrifice=tactical_combination_sacrifice,
        tactical_initiative_sacrifice=tactical_initiative_sacrifice,
        positional_structure_sacrifice=positional_structure_sacrifice,
        positional_space_sacrifice=positional_space_sacrifice,
        file_pressure_c=file_pressure_c_flag,
        first_choice=first_choice,
        missed_tactic=missed_tactic,
        conversion_precision=conversion_precision,
        panic_move=panic_move,
        tactical_recovery=tactical_recovery,
        metrics_before=metrics_before,
        metrics_played=metrics_played,
        metrics_best=metrics_best,
        component_deltas=component_deltas,
        opp_metrics_before=opp_metrics_before,
        opp_metrics_played=opp_metrics_played,
        opp_metrics_best=opp_metrics_best,
        opp_component_deltas=opp_component_deltas,
        coverage_delta=coverage_delta,
        tactical_weight=tactical_weight,
        mode=mode,
        analysis_context={
            "before": evaluation_before,
            "played": evaluation_played,
            "best": evaluation_best,
            "engine_meta": analysis_meta,
            "tactical_weight": tactical_weight
        },
        notes=notes,
        maneuver_precision_score=maneuver_precision_score,
        maneuver_timing_score=maneuver_timing_score,
    )
